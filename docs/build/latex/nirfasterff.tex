%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{NIRFASTerFF}
\date{Dec 13, 2024}
\release{1.1.1}
\author{Jiaming Cao, MILAB@UoB}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
NIRFAST was originally developed in 2001 as a MATLAB\sphinxhyphen{}based package used to model near\sphinxhyphen{}infrared light propagation through tissue and reconstruct images of optical biomarkers. At its core, NIRFAST is tool that does finite element modeling of the medium in which the light progagates, and calculates the fluence field by solving the diffusion equation.

\sphinxAtStartPar
A fully overhauled version, titled NIRFASTer, was published in 2018, thanks to the work of Dr. Stanisław Wojtkiewicz. In the new version, GPU support was added to the key algorithms, giving the software a dramatic boost in performance. The CPU versions of the algorithms were re\sphinxhyphen{}implemented in C++ with multithreading enabled, and the performance was improved considerably.

\sphinxAtStartPar
In this version, now titled NIRFASTerFF (Fast and Furious), the entire toolbox is re\sphinxhyphen{}written with Python as its interfacing language, while fully inter\sphinxhyphen{}operatable with the original Matlab version. The algorithms, running on both GPU and CPU, are yet again improved for even better performance.

\sphinxAtStartPar
This manual is a detailed documentation of all APIs in the package. Please also refer to the demos to see how the package is used in difference applications.


\chapter{Summary of the Functionalities}
\label{\detokenize{index:summary-of-the-functionalities}}
\sphinxAtStartPar
Mesh types supported: standard, fluorecence, and DCS

\sphinxAtStartPar
FEM solver calculates: CW fluence, FD fluence, TPSF, direct TR moments for standard and fluorecence mesh, and G1/g1 curve for DCS mesh

\sphinxAtStartPar
Analytical solution in semi\sphinxhyphen{}infinite medium for: CW/FD fluence, TPSF, and DCS G1/g1 curves

\sphinxAtStartPar
Jacobian matrices: CW for standard, fluorescence, and DCS mesh, and FD for standard and fluorescence mesh


\chapter{Link to the Matlab Version}
\label{\detokenize{index:link-to-the-matlab-version}}
\sphinxAtStartPar
The original Matlab\sphinxhyphen{}based NIRFAST and NIRFASTer are still avaibable for download, but we will gradually drop our support for them.

\sphinxAtStartPar
\sphinxurl{https://github.com/nirfast-admin/NIRFAST}

\sphinxAtStartPar
\sphinxurl{https://github.com/nirfaster/NIRFASTer}


\chapter{References}
\label{\detokenize{index:references}}
\sphinxAtStartPar
If you use our package, please cite,
\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
\sphinxAtStartPar
Dehghani, M.E. Eames, P.K. Yalavarthy, S.C. Davis, S. Srinivasan, C.M. Carpenter, B.W. Pogue, and K.D. Paulsen, “Near infrared optical tomography using NIRFAST: Algorithm for numerical model and image reconstruction,” Communications in Numerical Methods in Engineering, vol. 25, 711\sphinxhyphen{}732 (2009) \sphinxhref{https://doi.org/10.1002/cnm.1162}{doi:10.1002/cnm.1162}

\end{enumerate}


\chapter{API documentation}
\label{\detokenize{index:api-documentation}}
\sphinxstepscope


\section{nirfasterff}
\label{\detokenize{_autosummary/nirfasterff:module-nirfasterff}}\label{\detokenize{_autosummary/nirfasterff:nirfasterff}}\label{\detokenize{_autosummary/nirfasterff::doc}}\index{module@\spxentry{module}!nirfasterff@\spxentry{nirfasterff}}\index{nirfasterff@\spxentry{nirfasterff}!module@\spxentry{module}}\subsubsection*{Modules}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base:module-nirfasterff.base}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{base}}}}}
&
\sphinxAtStartPar
Core classes used in the pacakge
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward:module-nirfasterff.forward}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{forward}}}}}
&
\sphinxAtStartPar
Funtions for forward data calculation
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse:module-nirfasterff.inverse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{inverse}}}}}
&
\sphinxAtStartPar
Calculation of the Jacobian matrices and a basic Tikhonov regularization function
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.io:module-nirfasterff.io}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{io}}}}}
&
\sphinxAtStartPar
Some functions for reading/writing certain data types.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib:module-nirfasterff.lib}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lib}}}}}
&
\sphinxAtStartPar
Low\sphinxhyphen{}level functions implemented in C/C++, on both GPU and CPU
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math:module-nirfasterff.math}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{math}}}}}
&
\sphinxAtStartPar
Some low\sphinxhyphen{}level functions used by the forward solvers.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing:module-nirfasterff.meshing}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{meshing}}}}}
&
\sphinxAtStartPar
Functions used for mesh generation and quality check
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils:module-nirfasterff.utils}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utils}}}}}
&
\sphinxAtStartPar
Utility functions and auxiliary classes frequently used in the package.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.visualize:module-nirfasterff.visualize}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{visualize}}}}}
&
\sphinxAtStartPar
Functions for basic data visualization
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsection{nirfasterff.base}
\label{\detokenize{_autosummary/nirfasterff.base:module-nirfasterff.base}}\label{\detokenize{_autosummary/nirfasterff.base:nirfasterff-base}}\label{\detokenize{_autosummary/nirfasterff.base::doc}}\index{module@\spxentry{module}!nirfasterff.base@\spxentry{nirfasterff.base}}\index{nirfasterff.base@\spxentry{nirfasterff.base}!module@\spxentry{module}}
\sphinxAtStartPar
Core classes used in the pacakge
\subsubsection*{Modules}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data:module-nirfasterff.base.data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{data}}}}}
&
\sphinxAtStartPar
Defining some data classes, which are the return types of the fem data calculation functions
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh:module-nirfasterff.base.dcs_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dcs\_mesh}}}}}
&
\sphinxAtStartPar
Define the DCS mesh class.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh:module-nirfasterff.base.fluor_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fluor\_mesh}}}}}
&
\sphinxAtStartPar
Define the fluorescence mesh class
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes:module-nirfasterff.base.optodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{optodes}}}}}
&
\sphinxAtStartPar
Define the optode class, an instance of which can be either a source or a detector
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh:module-nirfasterff.base.stnd_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{stnd\_mesh}}}}}
&
\sphinxAtStartPar
Define the standard mesh class
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.base.data}
\label{\detokenize{_autosummary/nirfasterff.base.data:module-nirfasterff.base.data}}\label{\detokenize{_autosummary/nirfasterff.base.data:nirfasterff-base-data}}\label{\detokenize{_autosummary/nirfasterff.base.data::doc}}\index{module@\spxentry{module}!nirfasterff.base.data@\spxentry{nirfasterff.base.data}}\index{nirfasterff.base.data@\spxentry{nirfasterff.base.data}!module@\spxentry{module}}
\sphinxAtStartPar
Defining some data classes, which are the return types of the fem data calculation functions
\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DCSdata}}}}}()
&
\sphinxAtStartPar
Class holding DCS data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FDdata}}}}}()
&
\sphinxAtStartPar
Class holding FD/CW data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FLdata}}}}}()
&
\sphinxAtStartPar
Class holding FD/CW fluorescence data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TPSFdata}}}}}()
&
\sphinxAtStartPar
Class holding time\sphinxhyphen{}resolved TPSF data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TRMomentsdata}}}}}()
&
\sphinxAtStartPar
Class holding time\sphinxhyphen{}resolved moments data calculated using Mellin transform.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flTPSFdata}}}}}()
&
\sphinxAtStartPar
Class holding fluorescence time\sphinxhyphen{}resolved TPSF data.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flTRMomentsdata}}}}}()
&
\sphinxAtStartPar
Class holding fluorescence TR moments data calculated using Mellin transform.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{meshvol}}}}}()
&
\sphinxAtStartPar
Small class holding the information needed for converting between mesh and volumetric space.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.base.data.DCSdata}
\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff-base-data-dcsdata}}\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata::doc}}\index{DCSdata (class in nirfasterff.base.data)@\spxentry{DCSdata}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{DCSdata}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class holding DCS data.
\index{phi (nirfasterff.base.data.DCSdata attribute)@\spxentry{phi}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.phi}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phi}}}
\pysigstopsignatures
\sphinxAtStartPar
steady\sphinxhyphen{}state fluence from each source. If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid.

\sphinxAtStartPar
Last dimension has the size of the number of sources

\sphinxAtStartPar
This is the same as nirfasterff.base.FDdata.phi, when modulation frequency is zero
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.data.DCSdata attribute)@\spxentry{link}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
Defining all the channels (i.e. source\sphinxhyphen{}detector pairs). Copied from mesh.link
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{amplitude (nirfasterff.base.data.DCSdata attribute)@\spxentry{amplitude}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.amplitude}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{amplitude}}}
\pysigstopsignatures
\sphinxAtStartPar
Steady\sphinxhyphen{}state amplitude of each channel. Size (NChannel,)

\sphinxAtStartPar
This is the same as nirfasterff.base.FDdata.amplitude, when modulation frequency is zero
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{tau\_DCS (nirfasterff.base.data.DCSdata attribute)@\spxentry{tau\_DCS}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.tau_DCS}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{tau\_DCS}}}
\pysigstopsignatures
\sphinxAtStartPar
time vector in seconds
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{phi\_DCS (nirfasterff.base.data.DCSdata attribute)@\spxentry{phi\_DCS}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.phi_DCS}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phi\_DCS}}}
\pysigstopsignatures
\sphinxAtStartPar
G1 in medium from each source at each time step . If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid

\sphinxAtStartPar
shape{[}\sphinxhyphen{}1{]} equals length of tau\_DCS, and shape{[}\sphinxhyphen{}2{]} equals number of sources
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{G1\_DCS (nirfasterff.base.data.DCSdata attribute)@\spxentry{G1\_DCS}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.G1_DCS}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{G1\_DCS}}}
\pysigstopsignatures
\sphinxAtStartPar
G1 curve as is calculated from the correlation diffusion equation. Size: (NChannel, NTime)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{g1\_DCS (nirfasterff.base.data.DCSdata attribute)@\spxentry{g1\_DCS}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.g1_DCS}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{g1\_DCS}}}
\pysigstopsignatures
\sphinxAtStartPar
g1 curve, i.e. G1 normalized by amplitudes. Size: (NChannel, NTime)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.data.DCSdata attribute)@\spxentry{vol}\spxextra{nirfasterff.base.data.DCSdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
Information needed to convert between volumetric and mesh space. Copied from mesh.vol
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfaseterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.DCSdata method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.DCSdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Checks if data is in volumetric space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.togrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{togrid}}}}}(mesh)
&
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.tomesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tomesh}}}}}(mesh)
&
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{isvol() (nirfasterff.base.data.DCSdata method)@\spxentry{isvol()}\spxextra{nirfasterff.base.data.DCSdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if data is in volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if data is in volumetric space, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (nirfasterff.base.data.DCSdata method)@\spxentry{togrid()}\spxextra{nirfasterff.base.data.DCSdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.togrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{togrid}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol. If it is empty, the function does nothing.

\sphinxAtStartPar
If data is already in volumetric space, function casts data to the new volumetric space

\sphinxAtStartPar
CAUTION: This OVERRIDES the fields phi and phi\_DCS
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.dcsmesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{tomesh() (nirfasterff.base.data.DCSdata method)@\spxentry{tomesh()}\spxextra{nirfasterff.base.data.DCSdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata.tomesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{tomesh}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty, the function does nothing.

\sphinxAtStartPar
CAUTION: This OVERRIDES fields phi and phi\_DCS
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.dcsmesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.base.data.FDdata}
\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff-base-data-fddata}}\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata::doc}}\index{FDdata (class in nirfasterff.base.data)@\spxentry{FDdata}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{FDdata}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class holding FD/CW data.
\index{phi (nirfasterff.base.data.FDdata attribute)@\spxentry{phi}\spxextra{nirfasterff.base.data.FDdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.phi}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phi}}}
\pysigstopsignatures
\sphinxAtStartPar
Fluence from each source. If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid. Last dimension has the size of the number of sources
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{complex (nirfasterff.base.data.FDdata attribute)@\spxentry{complex}\spxextra{nirfasterff.base.data.FDdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.complex}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{complex}}}
\pysigstopsignatures
\sphinxAtStartPar
Complex amplitude of each channel. Same as amplitude in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double or complex double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.data.FDdata attribute)@\spxentry{link}\spxextra{nirfasterff.base.data.FDdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
Defining all the channels (i.e. source\sphinxhyphen{}detector pairs). Copied from mesh.link
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{amplitude (nirfasterff.base.data.FDdata attribute)@\spxentry{amplitude}\spxextra{nirfasterff.base.data.FDdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.amplitude}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{amplitude}}}
\pysigstopsignatures
\sphinxAtStartPar
Absolute amplitude of each channel. I.e. amplitude=abs(complex)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{phase (nirfasterff.base.data.FDdata attribute)@\spxentry{phase}\spxextra{nirfasterff.base.data.FDdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.phase}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phase}}}
\pysigstopsignatures
\sphinxAtStartPar
phase data of each channel. All zero in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.data.FDdata attribute)@\spxentry{vol}\spxextra{nirfasterff.base.data.FDdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
Information needed to convert between volumetric and mesh space. Copied from mesh.vol
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfaseterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.FDdata method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.FDdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Checks if data is in volumetric space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.togrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{togrid}}}}}(mesh)
&
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.tomesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tomesh}}}}}(mesh)
&
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{isvol() (nirfasterff.base.data.FDdata method)@\spxentry{isvol()}\spxextra{nirfasterff.base.data.FDdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if data is in volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if data is in volumetric space, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (nirfasterff.base.data.FDdata method)@\spxentry{togrid()}\spxextra{nirfasterff.base.data.FDdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.togrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{togrid}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol. If it is empty, the function does nothing.

\sphinxAtStartPar
If data is already in volumetric space, function casts data to the new volumetric space

\sphinxAtStartPar
CAUTION: This OVERRIDES the field phi
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{tomesh() (nirfasterff.base.data.FDdata method)@\spxentry{tomesh()}\spxextra{nirfasterff.base.data.FDdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata.tomesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{tomesh}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty, the function does nothing.

\sphinxAtStartPar
CAUTION: This OVERRIDES the field phi
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.base.data.FLdata}
\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff-base-data-fldata}}\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata::doc}}\index{FLdata (class in nirfasterff.base.data)@\spxentry{FLdata}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{FLdata}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class holding FD/CW fluorescence data.
\index{phix (nirfasterff.base.data.FLdata attribute)@\spxentry{phix}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.phix}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phix}}}
\pysigstopsignatures
\sphinxAtStartPar
intrinsic fluence from each source at excitation wavelength. If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid. Last dimension has the size of the number of sources
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{phimm (nirfasterff.base.data.FLdata attribute)@\spxentry{phimm}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.phimm}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phimm}}}
\pysigstopsignatures
\sphinxAtStartPar
intrinsic from each source at emission wavelength.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{phifl (nirfasterff.base.data.FLdata attribute)@\spxentry{phifl}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.phifl}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phifl}}}
\pysigstopsignatures
\sphinxAtStartPar
fluorescence emission fluence
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{complexx (nirfasterff.base.data.FLdata attribute)@\spxentry{complexx}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.complexx}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{complexx}}}
\pysigstopsignatures
\sphinxAtStartPar
Complex amplitude of each channel, intrinsic excitation. Same as amplitude in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double or complex double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{complexmm (nirfasterff.base.data.FLdata attribute)@\spxentry{complexmm}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.complexmm}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{complexmm}}}
\pysigstopsignatures
\sphinxAtStartPar
Complex amplitude of each channel, intrinsic emission. Same as amplitude in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double or complex double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{complexfl (nirfasterff.base.data.FLdata attribute)@\spxentry{complexfl}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.complexfl}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{complexfl}}}
\pysigstopsignatures
\sphinxAtStartPar
Complex amplitude of each channel, fluorescence emission. Same as amplitude in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double or complex double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.data.FLdata attribute)@\spxentry{link}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
Defining all the channels (i.e. source\sphinxhyphen{}detector pairs). Copied from mesh.link
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{amplitudex (nirfasterff.base.data.FLdata attribute)@\spxentry{amplitudex}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.amplitudex}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{amplitudex}}}
\pysigstopsignatures
\sphinxAtStartPar
Absolute amplitude of each channel, intrinsic excitation. I.e. amplitudex=abs(complexx)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{amplitudemm (nirfasterff.base.data.FLdata attribute)@\spxentry{amplitudemm}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.amplitudemm}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{amplitudemm}}}
\pysigstopsignatures
\sphinxAtStartPar
Absolute amplitude of each channel, intrinsic emission. I.e. amplitudemm=abs(complexmm)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{amplitudefl (nirfasterff.base.data.FLdata attribute)@\spxentry{amplitudefl}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.amplitudefl}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{amplitudefl}}}
\pysigstopsignatures
\sphinxAtStartPar
Absolute amplitude of each channel, fluorescence emission. I.e. amplitudefl=abs(complexfl)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{phasex (nirfasterff.base.data.FLdata attribute)@\spxentry{phasex}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.phasex}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phasex}}}
\pysigstopsignatures
\sphinxAtStartPar
phase data of each channel, intrinsic excitation. All zero in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{phasemm (nirfasterff.base.data.FLdata attribute)@\spxentry{phasemm}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.phasemm}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phasemm}}}
\pysigstopsignatures
\sphinxAtStartPar
phase data of each channel, intrinsic emission. All zero in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{phasefl (nirfasterff.base.data.FLdata attribute)@\spxentry{phasefl}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.phasefl}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phasefl}}}
\pysigstopsignatures
\sphinxAtStartPar
phase data of each channel, fluorescence emission. All zero in case of CW data
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.data.FLdata attribute)@\spxentry{vol}\spxextra{nirfasterff.base.data.FLdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
Information needed to convert between volumetric and mesh space. Copied from mesh.vol
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfaseterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.FLdata method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.FLdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Checks if data is in volumetric space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.togrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{togrid}}}}}(mesh)
&
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.tomesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tomesh}}}}}(mesh)
&
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{isvol() (nirfasterff.base.data.FLdata method)@\spxentry{isvol()}\spxextra{nirfasterff.base.data.FLdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if data is in volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if data is in volumetric space, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (nirfasterff.base.data.FLdata method)@\spxentry{togrid()}\spxextra{nirfasterff.base.data.FLdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.togrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{togrid}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol. If it is empty, the function does nothing.

\sphinxAtStartPar
If data is already in volumetric space, function casts data to the new volumetric space

\sphinxAtStartPar
CAUTION: This OVERRIDES the fields phix, phimm, and phifl, if they are defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{tomesh() (nirfasterff.base.data.FLdata method)@\spxentry{tomesh()}\spxextra{nirfasterff.base.data.FLdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata.tomesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{tomesh}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty, the function does nothing.

\sphinxAtStartPar
CAUTION: This OVERRIDES fields phix, phimm, and phifl, if they are defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.base.data.TPSFdata}
\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff-base-data-tpsfdata}}\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata::doc}}\index{TPSFdata (class in nirfasterff.base.data)@\spxentry{TPSFdata}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{TPSFdata}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class holding time\sphinxhyphen{}resolved TPSF data.
\index{phi (nirfasterff.base.data.TPSFdata attribute)@\spxentry{phi}\spxextra{nirfasterff.base.data.TPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.phi}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phi}}}
\pysigstopsignatures
\sphinxAtStartPar
TPSF from each source at each spatial location. If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid

\sphinxAtStartPar
Shape: NNodes x num\_sources x time\_steps

\sphinxAtStartPar
OR: len(xgrid) x len(ygrid) x len(zgrid) x num\_sources x time\_steps

\sphinxAtStartPar
None by default, and only contains data if ‘field’ option is set to True when calculating forward data.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array or None

\end{description}\end{quote}

\end{fulllineitems}

\index{time (nirfasterff.base.data.TPSFdata attribute)@\spxentry{time}\spxextra{nirfasterff.base.data.TPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.time}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{time}}}
\pysigstopsignatures
\sphinxAtStartPar
time vector, in seconds
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{tpsf (nirfasterff.base.data.TPSFdata attribute)@\spxentry{tpsf}\spxextra{nirfasterff.base.data.TPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.tpsf}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{tpsf}}}
\pysigstopsignatures
\sphinxAtStartPar
TPSF measured at each channel. Size: (NChannels, time\_steps)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.data.TPSFdata attribute)@\spxentry{link}\spxextra{nirfasterff.base.data.TPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
Defining all the channels (i.e. source\sphinxhyphen{}detector pairs). Copied from mesh.link
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.data.TPSFdata attribute)@\spxentry{vol}\spxextra{nirfasterff.base.data.TPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
Information needed to convert between volumetric and mesh space. Copied from mesh.vol
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfaseterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.TPSFdata method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.TPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Checks if data is in volumetric space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.togrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{togrid}}}}}(mesh)
&
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.tomesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tomesh}}}}}(mesh)
&
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{isvol() (nirfasterff.base.data.TPSFdata method)@\spxentry{isvol()}\spxextra{nirfasterff.base.data.TPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if data is in volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if data is in volumetric space, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (nirfasterff.base.data.TPSFdata method)@\spxentry{togrid()}\spxextra{nirfasterff.base.data.TPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.togrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{togrid}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol. If it is empty or data.phi==None, the function does nothing.

\sphinxAtStartPar
If data is already in volumetric space, function casts data to the new volumetric space

\sphinxAtStartPar
CAUTION: This OVERRIDES the field phi, if it is defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{tomesh() (nirfasterff.base.data.TPSFdata method)@\spxentry{tomesh()}\spxextra{nirfasterff.base.data.TPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata.tomesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{tomesh}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty or data.phi==None, the function does nothing.

\sphinxAtStartPar
CAUTION: This OVERRIDES field phi, if it is defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.base.data.TRMomentsdata}
\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff-base-data-trmomentsdata}}\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata::doc}}\index{TRMomentsdata (class in nirfasterff.base.data)@\spxentry{TRMomentsdata}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{TRMomentsdata}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class holding time\sphinxhyphen{}resolved moments data calculated using Mellin transform.
\index{phi (nirfasterff.base.data.TRMomentsdata attribute)@\spxentry{phi}\spxextra{nirfasterff.base.data.TRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.phi}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phi}}}
\pysigstopsignatures
\sphinxAtStartPar
moments from each source at each spatial location. If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid

\sphinxAtStartPar
Shape: NNodes x num\_sources x (max\_moment\_order + 1)

\sphinxAtStartPar
OR: len(xgrid) x len(ygrid) x len(zgrid) x num\_sources x (max\_moment\_order + 1)

\sphinxAtStartPar
None by default, and only contains data if ‘field’ option is set to True when calculating forward data.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array or None

\end{description}\end{quote}

\end{fulllineitems}

\index{moments (nirfasterff.base.data.TRMomentsdata attribute)@\spxentry{moments}\spxextra{nirfasterff.base.data.TRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.moments}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{moments}}}
\pysigstopsignatures
\sphinxAtStartPar
moments for each channel. i\sphinxhyphen{}th column contains i\sphinxhyphen{}th moment as measured at each channel. Size: (NChannels, max\_moment\_order + 1)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.data.TRMomentsdata attribute)@\spxentry{link}\spxextra{nirfasterff.base.data.TRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
Defining all the channels (i.e. source\sphinxhyphen{}detector pairs). Copied from mesh.link
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.data.TRMomentsdata attribute)@\spxentry{vol}\spxextra{nirfasterff.base.data.TRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
Information needed to convert between volumetric and mesh space. Copied from mesh.vol
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfaseterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.TRMomentsdata method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.TRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Checks if data is in volumetric space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.togrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{togrid}}}}}(mesh)
&
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.tomesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tomesh}}}}}(mesh)
&
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{isvol() (nirfasterff.base.data.TRMomentsdata method)@\spxentry{isvol()}\spxextra{nirfasterff.base.data.TRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if data is in volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if data is in volumetric space, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (nirfasterff.base.data.TRMomentsdata method)@\spxentry{togrid()}\spxextra{nirfasterff.base.data.TRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.togrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{togrid}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol. If it is empty or data.phi==None, the function does nothing.

\sphinxAtStartPar
If data is already in volumetric space, function casts data to the new volumetric space

\sphinxAtStartPar
CAUTION: This OVERRIDES the field phi, if it is defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{tomesh() (nirfasterff.base.data.TRMomentsdata method)@\spxentry{tomesh()}\spxextra{nirfasterff.base.data.TRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata.tomesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{tomesh}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty or data.phi==None, the function does nothing.

\sphinxAtStartPar
CAUTION: This OVERRIDES field phi, if it is defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.base.data.flTPSFdata}
\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff-base-data-fltpsfdata}}\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata::doc}}\index{flTPSFdata (class in nirfasterff.base.data)@\spxentry{flTPSFdata}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{flTPSFdata}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class holding fluorescence time\sphinxhyphen{}resolved TPSF data.
\index{phix (nirfasterff.base.data.flTPSFdata attribute)@\spxentry{phix}\spxextra{nirfasterff.base.data.flTPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.phix}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phix}}}
\pysigstopsignatures
\sphinxAtStartPar
TPSF at exciation wavelength from each source at each spatial location. If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid

\sphinxAtStartPar
Shape: NNodes x num\_sources x time\_steps

\sphinxAtStartPar
OR: len(xgrid) x len(ygrid) x len(zgrid) x num\_sources x time\_steps

\sphinxAtStartPar
None by default, and only contains data if ‘field’ option is set to True when calculating forward data.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{phifl (nirfasterff.base.data.flTPSFdata attribute)@\spxentry{phifl}\spxextra{nirfasterff.base.data.flTPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.phifl}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phifl}}}
\pysigstopsignatures
\sphinxAtStartPar
similar to phix, but for fluorescence emission
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{time (nirfasterff.base.data.flTPSFdata attribute)@\spxentry{time}\spxextra{nirfasterff.base.data.flTPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.time}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{time}}}
\pysigstopsignatures
\sphinxAtStartPar
time vector, in seconds
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{tpsfx (nirfasterff.base.data.flTPSFdata attribute)@\spxentry{tpsfx}\spxextra{nirfasterff.base.data.flTPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.tpsfx}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{tpsfx}}}
\pysigstopsignatures
\sphinxAtStartPar
TPSF measured at each channel, excitation. Size: (NChannels, time\_steps)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.data.flTPSFdata attribute)@\spxentry{link}\spxextra{nirfasterff.base.data.flTPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
Defining all the channels (i.e. source\sphinxhyphen{}detector pairs). Copied from mesh.link
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.data.flTPSFdata attribute)@\spxentry{vol}\spxextra{nirfasterff.base.data.flTPSFdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
Information needed to convert between volumetric and mesh space. Copied from mesh.vol
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfaseterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.flTPSFdata method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.flTPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Checks if data is in volumetric space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.togrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{togrid}}}}}(mesh)
&
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.tomesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tomesh}}}}}(mesh)
&
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{isvol() (nirfasterff.base.data.flTPSFdata method)@\spxentry{isvol()}\spxextra{nirfasterff.base.data.flTPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if data is in volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if data is in volumetric space, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (nirfasterff.base.data.flTPSFdata method)@\spxentry{togrid()}\spxextra{nirfasterff.base.data.flTPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.togrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{togrid}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol. If it is empty or data.phix==None, the function does nothing.

\sphinxAtStartPar
If data is already in volumetric space, function casts data to the new volumetric space

\sphinxAtStartPar
CAUTION: This OVERRIDES the fields phix and phifl, if they are defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{tomesh() (nirfasterff.base.data.flTPSFdata method)@\spxentry{tomesh()}\spxextra{nirfasterff.base.data.flTPSFdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata.tomesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{tomesh}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty or data.phix==None, the function does nothing.

\sphinxAtStartPar
CAUTION: This OVERRIDES fields phix and phifl, if they are defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.base.data.flTRMomentsdata}
\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff-base-data-fltrmomentsdata}}\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata::doc}}\index{flTRMomentsdata (class in nirfasterff.base.data)@\spxentry{flTRMomentsdata}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{flTRMomentsdata}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class holding fluorescence TR moments data calculated using Mellin transform.
\index{phix (nirfasterff.base.data.flTRMomentsdata attribute)@\spxentry{phix}\spxextra{nirfasterff.base.data.flTRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.phix}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phix}}}
\pysigstopsignatures
\sphinxAtStartPar
moments at excitation wavelength from each source at each spatial location. If mesh contains non\sphinxhyphen{}tempty field vol, this will be represented on the grid

\sphinxAtStartPar
Shape: NNodes x num\_sources x (max\_moment\_order + 1)

\sphinxAtStartPar
OR: len(xgrid) x len(ygrid) x len(zgrid) x num\_sources x (max\_moment\_order + 1)

\sphinxAtStartPar
None by default, and only contains data if ‘field’ option is set to True when calculating forward data.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{phifl (nirfasterff.base.data.flTRMomentsdata attribute)@\spxentry{phifl}\spxextra{nirfasterff.base.data.flTRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.phifl}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{phifl}}}
\pysigstopsignatures
\sphinxAtStartPar
similar to phix, but for fluorescence emission
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{momentsx (nirfasterff.base.data.flTRMomentsdata attribute)@\spxentry{momentsx}\spxextra{nirfasterff.base.data.flTRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.momentsx}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{momentsx}}}
\pysigstopsignatures
\sphinxAtStartPar
moments for each channel, exciation. i\sphinxhyphen{}th column contains i\sphinxhyphen{}th moment. Size: (NChannels, max\_moment\_order + 1)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{momentsfl (nirfasterff.base.data.flTRMomentsdata attribute)@\spxentry{momentsfl}\spxextra{nirfasterff.base.data.flTRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.momentsfl}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{momentsfl}}}
\pysigstopsignatures
\sphinxAtStartPar
moments for each channel, fluorescence emission. i\sphinxhyphen{}th column contains i\sphinxhyphen{}th moment. Size: (NChannels, max\_moment\_order + 1)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.data.flTRMomentsdata attribute)@\spxentry{link}\spxextra{nirfasterff.base.data.flTRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
Defining all the channels (i.e. source\sphinxhyphen{}detector pairs). Copied from mesh.link
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.data.flTRMomentsdata attribute)@\spxentry{vol}\spxextra{nirfasterff.base.data.flTRMomentsdata attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
Information needed to convert between volumetric and mesh space. Copied from mesh.vol
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfaseterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.flTRMomentsdata method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.flTRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Checks if data is in volumetric space.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.togrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{togrid}}}}}(mesh)
&
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.tomesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tomesh}}}}}(mesh)
&
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{isvol() (nirfasterff.base.data.flTRMomentsdata method)@\spxentry{isvol()}\spxextra{nirfasterff.base.data.flTRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if data is in volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if data is in volumetric space, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (nirfasterff.base.data.flTRMomentsdata method)@\spxentry{togrid()}\spxextra{nirfasterff.base.data.flTRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.togrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{togrid}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data to volumetric space as is defined in mesh.vol. If it is empty or data.phix==None, the function does nothing.

\sphinxAtStartPar
If data is already in volumetric space, function casts data to the new volumetric space

\sphinxAtStartPar
CAUTION: This OVERRIDES the fields phix and phifl, if they are defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{tomesh() (nirfasterff.base.data.flTRMomentsdata method)@\spxentry{tomesh()}\spxextra{nirfasterff.base.data.flTRMomentsdata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata.tomesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{tomesh}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty or data.phix==None, the function does nothing.

\sphinxAtStartPar
CAUTION: This OVERRIDES fields phix and phifl, if they are defined
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh whose .vol attribute is used to do the conversion.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.base.data.meshvol}
\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff-base-data-meshvol}}\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol::doc}}\index{meshvol (class in nirfasterff.base.data)@\spxentry{meshvol}\spxextra{class in nirfasterff.base.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.data.}}\sphinxbfcode{\sphinxupquote{meshvol}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Small class holding the information needed for converting between mesh and volumetric space. Values calculated by nirfasterff.base.*mesh.gen\_intmat

\sphinxAtStartPar
Note that the volumetric space, defined by xgrid, ygrid, and zgrid (empty for 2D mesh), must be uniform
\index{xgrid (nirfasterff.base.data.meshvol attribute)@\spxentry{xgrid}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.xgrid}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{xgrid}}}
\pysigstopsignatures
\sphinxAtStartPar
x grid of the volumetric space. In mm
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{ygrid (nirfasterff.base.data.meshvol attribute)@\spxentry{ygrid}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.ygrid}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{ygrid}}}
\pysigstopsignatures
\sphinxAtStartPar
y grid of the volumetric space. In mm
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{zgrid (nirfasterff.base.data.meshvol attribute)@\spxentry{zgrid}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.zgrid}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{zgrid}}}
\pysigstopsignatures
\sphinxAtStartPar
z grid of the volumetric space. In mm. Empty for 2D meshes
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{mesh2grid (nirfasterff.base.data.meshvol attribute)@\spxentry{mesh2grid}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.mesh2grid}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{mesh2grid}}}
\pysigstopsignatures
\sphinxAtStartPar
matrix converting a vector in mesh space to volumetric space, done by mesh2grid.dot(data)

\sphinxAtStartPar
The result is vectorized in ‘F’ (Matlab) order

\sphinxAtStartPar
Size: (len(xgrid)*len(ygrid)*len(zgrid), NNodes)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double CSR sparse matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{gridinmesh (nirfasterff.base.data.meshvol attribute)@\spxentry{gridinmesh}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.gridinmesh}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{gridinmesh}}}
\pysigstopsignatures
\sphinxAtStartPar
indices (one\sphinxhyphen{}based) of data points in the volumetric space that are within the mesh space, vectorized in ‘F’ order.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{res (nirfasterff.base.data.meshvol attribute)@\spxentry{res}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.res}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{res}}}
\pysigstopsignatures
\sphinxAtStartPar
resolution in x, y, z (if 3D) direction, in mm. Size (2,) or (3,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{grid2mesh (nirfasterff.base.data.meshvol attribute)@\spxentry{grid2mesh}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.grid2mesh}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{grid2mesh}}}
\pysigstopsignatures
\sphinxAtStartPar
matrix converting volumetric data, vectorized in ‘F’ order, to mesh space. Done by grid2mesh.dot(data)

\sphinxAtStartPar
Size (Nnodes, len(xgrid)*len(ygrid)*len(ygrid))
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double CSR sparse matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{meshingrid (nirfasterff.base.data.meshvol attribute)@\spxentry{meshingrid}\spxextra{nirfasterff.base.data.meshvol attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.meshingrid}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{meshingrid}}}
\pysigstopsignatures
\sphinxAtStartPar
indices (one\sphinxhyphen{}based) of data points in the mesh space that are within the volumetric space
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.data.meshvol method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.data.meshvol method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.data.meshvol:nirfasterff.base.data.meshvol.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.base.dcs\_mesh}
\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh:module-nirfasterff.base.dcs_mesh}}\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh:nirfasterff-base-dcs-mesh}}\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh::doc}}\index{module@\spxentry{module}!nirfasterff.base.dcs\_mesh@\spxentry{nirfasterff.base.dcs\_mesh}}\index{nirfasterff.base.dcs\_mesh@\spxentry{nirfasterff.base.dcs\_mesh}!module@\spxentry{module}}
\sphinxAtStartPar
Define the DCS mesh class. Assuming all motions are Brownian.
\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dcsmesh}}}}}()
&
\sphinxAtStartPar
Main class for standard mesh.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.base.dcs\_mesh.dcsmesh}
\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff-base-dcs-mesh-dcsmesh}}\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh::doc}}\index{dcsmesh (class in nirfasterff.base.dcs\_mesh)@\spxentry{dcsmesh}\spxextra{class in nirfasterff.base.dcs\_mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.dcs\_mesh.}}\sphinxbfcode{\sphinxupquote{dcsmesh}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Main class for standard mesh. The methods should cover most of the commonly\sphinxhyphen{}used functionalities
\index{name (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{name}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.name}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
name of the mesh. Default: ‘EmptyMesh’
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{nodes (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{nodes}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.nodes}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{nodes}}}
\pysigstopsignatures
\sphinxAtStartPar
locations of nodes in the mesh. Unit: mm. Size (NNodes, dim)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{bndvtx (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{bndvtx}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.bndvtx}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{bndvtx}}}
\pysigstopsignatures
\sphinxAtStartPar
indicator of whether a node is at boundary (1) or internal (0). Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{type (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{type}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.type}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{type}}}
\pysigstopsignatures
\sphinxAtStartPar
type of the mesh. It is always ‘dcs’.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{mua (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{mua}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.mua}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{mua}}}
\pysigstopsignatures
\sphinxAtStartPar
absorption coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{kappa (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{kappa}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.kappa}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{kappa}}}
\pysigstopsignatures
\sphinxAtStartPar
diffusion coefficient (mm) at each node. Size (NNodes,). Defined as 1/(3*(mua + mus))
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{ri (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{ri}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.ri}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{ri}}}
\pysigstopsignatures
\sphinxAtStartPar
refractive index at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{mus (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{mus}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.mus}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{mus}}}
\pysigstopsignatures
\sphinxAtStartPar
reduced scattering coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
(double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{wv\_DCS (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{wv\_DCS}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.wv_DCS}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{wv\_DCS}}}
\pysigstopsignatures
\sphinxAtStartPar
wavelength used (nm)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{alpha (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{alpha}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.alpha}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{alpha}}}
\pysigstopsignatures
\sphinxAtStartPar
fraction of photon scattering events that occur from moving particles in the medium (a.u.). Size (NNodes, NFlow)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{Db (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{Db}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.Db}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{Db}}}
\pysigstopsignatures
\sphinxAtStartPar
effective diffusion coefficient in Brownian motion (mm\textasciicircum{}2/s). Size (NNodes, NFlow)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{aDb (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{aDb}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.aDb}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{aDb}}}
\pysigstopsignatures
\sphinxAtStartPar
Defined as np.sum(a*Db,axis=1). This lumped parameter (mm\textasciicircum{}2/s) is what is actually used in data genreation. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{elements (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{elements}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.elements}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{elements}}}
\pysigstopsignatures
\sphinxAtStartPar
triangulation (tetrahedrons or triangles) of the mesh, Size (NElements, dim+1)

\sphinxAtStartPar
Row i contains the indices of the nodes that form tetrahedron/triangle i

\sphinxAtStartPar
One\sphinxhyphen{}based indexing for direct interoperatability with the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{region (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{region}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.region}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{region}}}
\pysigstopsignatures
\sphinxAtStartPar
region labeling of each node. Starting from 1. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{source (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{source}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.source}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{source}}}
\pysigstopsignatures
\sphinxAtStartPar
information about the sources
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.optode

\end{description}\end{quote}

\end{fulllineitems}

\index{meas (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{meas}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.meas}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{meas}}}
\pysigstopsignatures
\sphinxAtStartPar
information about the the detectors
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.optode

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{link}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
list of source\sphinxhyphen{}detector pairs, i.e. channels. Size (NChannels,3)

\sphinxAtStartPar
First column: source; Second column: detector; Third column: active (1) or not (0)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{c (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{c}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.c}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{c}}}
\pysigstopsignatures
\sphinxAtStartPar
light speed (mm/sec) at each node.  Size (NNodes,). Defined as c0/ri, where c0 is the light speed in vacuum
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{ksi (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{ksi}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.ksi}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{ksi}}}
\pysigstopsignatures
\sphinxAtStartPar
photon fluence rate scale factor on the mesh\sphinxhyphen{}outside\_mesh boundary as derived from Fresenel’s law. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{element\_area (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{element\_area}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.element_area}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{element\_area}}}
\pysigstopsignatures
\sphinxAtStartPar
volume/area (mm\textasciicircum{}3 or mm\textasciicircum{}2) of each element. Size (NElements,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{support (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{support}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.support}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{support}}}
\pysigstopsignatures
\sphinxAtStartPar
total volume/area of all the elements each node belongs to. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.dcs\_mesh.dcsmesh attribute)@\spxentry{vol}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
object holding information for converting between mesh and volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.change_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{change\_prop}}}}}(idx, prop)
&
\sphinxAtStartPar
Change optical properties (mua, musp, ri, alpha and Db) at nodes specified in idx, and automatically change fields kappa, c, and ksi as well
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.femdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata}}}}}(tvec{[}, solver, opt{]})
&
\sphinxAtStartPar
Calculates steady\sphinxhyphen{}state fluences and G1/g1 curves for each source using a FEM solver, and then the boudary measurables for each channel
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_copy}}}}}(mesh)
&
\sphinxAtStartPar
Deep copy all fields from another mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_file}}}}}(file)
&
\sphinxAtStartPar
Read from classic NIRFAST mesh (ASCII) format, not checking the correctness of the loaded integration functions.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_mat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_mat}}}}}(matfile{[}, varname{]})
&
\sphinxAtStartPar
Read from Matlab .mat file that contains a NIRFASTer mesh struct.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_solid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_solid}}}}}(ele, nodes{[}, prop, src, det, link{]})
&
\sphinxAtStartPar
Construct a NIRFASTer mesh from a 3D solid mesh generated by a mesher.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_volume}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_volume}}}}}(vol{[}, param, prop, src, det, link{]})
&
\sphinxAtStartPar
Construct mesh from a segmented 3D volume using the built\sphinxhyphen{}in CGAL mesher.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.gen_intmat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_intmat}}}}}(xgrid, ygrid{[}, zgrid{]})
&
\sphinxAtStartPar
Calculate the information needed to convert data between mesh and volumetric space, specified by x, y, z (if 3D) grids.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Check if convertion matrices between mesh and volumetric spaces are calculated
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.jacobian}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian}}}}}(tvec{[}, normalize, solver, opt{]})
&
\sphinxAtStartPar
Calculates the Jacobian matrix
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.save_nirfast}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{save\_nirfast}}}}}(filename)
&
\sphinxAtStartPar
Save mesh in the classic NIRFASTer ASCII format, which is directly compatible with the Matlab version
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop}}}}}(prop)
&
\sphinxAtStartPar
Set optical properties of the whole mesh, using information provided in prop.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.touch_optodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_optodes}}}}}()
&
\sphinxAtStartPar
Moves all optodes (if non fixed) and recalculate the integration functions (i.e. barycentric coordinates).
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{change\_prop() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{change\_prop()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.change_prop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{change\_prop}}}
{\sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Change optical properties (mua, musp, ri, alpha and Db) at nodes specified in idx, and automatically change fields kappa, c, and ksi as well
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{}1}}) \textendash{} zero\sphinxhyphen{}based indices of nodes to change. If \sphinxtitleref{idx==\sphinxhyphen{}1}, function changes all the nodes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{length 6}}) \textendash{} new optical properties to be assigned to the specified nodes. {[}region mua(mm\sphinxhyphen{}1) musp(mm\sphinxhyphen{}1) ri alpha Db{]}.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{femdata() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{femdata()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.femdata}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{femdata}}}
{\sphinxparam{\DUrole{n}{tvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates steady\sphinxhyphen{}state fluences and G1/g1 curves for each source using a FEM solver, and then the boudary measurables for each channel

\sphinxAtStartPar
Assumes Brownian motion, that is, \(\langle\Delta r^2\rangle=6*\alpha Db*\tau\)

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set, fluence and G1 data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_DCS:nirfasterff.forward.femdata.femdata_DCS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_DCS()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_CW:nirfasterff.forward.femdata.femdata_stnd_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_CW()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} time vector (i.e. :math:\textasciigrave{}   au\textasciigrave{}) for the G1 curve, in seconds. It is usually a good idea to use log scale

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.DCSdata}) \textendash{} contains fluence, G1 curve, and g1 curve calculated at each spatial location, and also the boundary data.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DCSdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver when calculating the fluence field.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{from\_copy() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{from\_copy()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_copy}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_copy}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Deep copy all fields from another mesh.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh to copy from.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_file() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{from\_file()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_file}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_file}}}
{\sphinxparam{\DUrole{n}{file}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Read from classic NIRFAST mesh (ASCII) format, not checking the correctness of the loaded integration functions.

\sphinxAtStartPar
All fields after loading should be directly compatible with Matlab version.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the mesh. Any extension will be ignored.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{nirfasterff}\PYG{o}{.}\PYG{n}{base}\PYG{o}{.}\PYG{n}{dcsmesh}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{meshname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{from\_mat() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{from\_mat()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_mat}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_mat}}}
{\sphinxparam{\DUrole{n}{matfile}}\sphinxparamcomma \sphinxparam{\DUrole{n}{varname}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Read from Matlab .mat file that contains a NIRFASTer mesh struct. All fields copied as is without error checking.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{matfile}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the .mat file to load. Use of extension is optional.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
if your .mat file contains multiple variables, use this argument to specify which one to load. The default is None.

\sphinxAtStartPar
When \sphinxtitleref{varname==None}, \sphinxtitleref{matfile} should contain exatly one structure, which is a NIRFASTer mesh, or the function will do nothing


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_solid() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{from\_solid()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_solid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_solid}}}
{\sphinxparam{\DUrole{n}{ele}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{src}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{det}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{link}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Construct a NIRFASTer mesh from a 3D solid mesh generated by a mesher. Similar to the solidmesh2nirfast function in Matlab version.

\sphinxAtStartPar
Can also set the optical properties and optodes if supplied
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int/double NumPy array}}) \textendash{} 
\sphinxAtStartPar
element list in one\sphinxhyphen{}based indexing. If four columns, all nodes will be labeled as region 1

\sphinxAtStartPar
If five columns, the last column will be used for region labeling.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations in the mesh. Unit: mm. Size (NNodes,3).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, calls \sphinxtitleref{dcsmesh.set\_prop()} and sets the optical properties in the mesh. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{src}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the sources and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{det}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the detectors and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{link}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the channel information. Uses one\sphinxhyphen{}based indexing. The default is None.

\sphinxAtStartPar
Each row represents a channel, in the form of \sphinxtitleref{{[}src, det, active{]}}, where \sphinxtitleref{active} is 0 or 1

\sphinxAtStartPar
If \sphinxtitleref{link} contains only two columns, all channels are considered active.


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_volume() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{from\_volume()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.from_volume}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_volume}}}
{\sphinxparam{\DUrole{n}{vol}}\sphinxparamcomma \sphinxparam{\DUrole{n}{param}\DUrole{o}{=}\DUrole{default_value}{utils.MeshingParams()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{src}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{det}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{link}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Construct mesh from a segmented 3D volume using the built\sphinxhyphen{}in CGAL mesher. Calls stndmesh.from\_solid after meshing step.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vol}} (\sphinxstyleliteralemphasis{\sphinxupquote{uint8 NumPy array}}) \textendash{} 3D segmented volume to be meshed. 0 is considered as outside. Regions labeled using unique integers.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.MeshingParams}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
parameters used in the CGAL mesher. If not specified, uses the default parameters defined in nirfasterff.utils.MeshingParams().

\sphinxAtStartPar
Please modify fields xPixelSpacing, yPixelSpacing, and SliceThickness if your volume doesn’t have {[}1,1,1{]} resolution

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshingParams()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, calls \sphinxtitleref{dcsmesh.set\_prop()} and sets the optical properties in the mesh. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{src}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the sources and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{det}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the detectors and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{link}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the channel information. Uses one\sphinxhyphen{}based indexing. The default is None.

\sphinxAtStartPar
Each row represents a channel, in the form of \sphinxtitleref{{[}src, det, active{]}}, where \sphinxtitleref{active} is 0 or 1

\sphinxAtStartPar
If \sphinxtitleref{link} contains only two columns, all channels are considered active.


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_intmat() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{gen\_intmat()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.gen_intmat}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{gen\_intmat}}}
{\sphinxparam{\DUrole{n}{xgrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ygrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zgrid}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the information needed to convert data between mesh and volumetric space, specified by x, y, z (if 3D) grids.

\sphinxAtStartPar
All grids must be uniform. The results will from a nirfasterff.base.meshvol object stored in field .vol

\sphinxAtStartPar
If field .vol already exists, it will be calculated again, and a warning will be thrown
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} x grid in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ygrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} x grid in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} x grid in mm. Leave empty for 2D meshes. The default is {[}{]}.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if grids not uniform, or zgrid empty for 3D mesh

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{isvol() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{isvol()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Check if convertion matrices between mesh and volumetric spaces are calculated
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if attribute \sphinxtitleref{.vol} is calculate, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{jacobian() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{jacobian()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.jacobian}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{jacobian}}}
{\sphinxparam{\DUrole{n}{tvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the Jacobian matrix

\sphinxAtStartPar
Returns the Jacobian, direct field data, and the adjoint data

\sphinxAtStartPar
One Jacobian is calcualted at each time point in tvec, and the derivative is taken with regard to aDb
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}) \textendash{} time vector used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True, Jacobbians are normalized to the measured boundary amplitude. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel, NVoxel, NTime)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(tvec)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(tvec) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_DCS:nirfasterff.inverse.jacobian_DCS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_DCS()}}}}}


\end{sphinxseealso}


\end{fulllineitems}

\index{save\_nirfast() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{save\_nirfast()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.save_nirfast}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{save\_nirfast}}}
{\sphinxparam{\DUrole{n}{filename}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Save mesh in the classic NIRFASTer ASCII format, which is directly compatible with the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the file to be saved as. Should have no extensions.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_prop() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{set\_prop()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.set_prop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{set\_prop}}}
{\sphinxparam{\DUrole{n}{prop}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Set optical properties of the whole mesh, using information provided in prop.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} 
\sphinxAtStartPar
optical property info, similar to the MCX format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{region} \PYG{n}{mua}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{ri} \PYG{n}{alpha} \PYG{n}{Db}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{region} \PYG{n}{mua}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{ri} \PYG{n}{alpha} \PYG{n}{Db}\PYG{p}{]}
\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where ‘region’ is the region label, and they should match exactly with unique(mesh.region). The order doesn’t matter.


\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{touch\_optodes() (nirfasterff.base.dcs\_mesh.dcsmesh method)@\spxentry{touch\_optodes()}\spxextra{nirfasterff.base.dcs\_mesh.dcsmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.dcs_mesh.dcsmesh:nirfasterff.base.dcs_mesh.dcsmesh.touch_optodes}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{touch\_optodes}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Moves all optodes (if non fixed) and recalculate the integration functions (i.e. barycentric coordinates).

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.base.fluor\_mesh}
\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh:module-nirfasterff.base.fluor_mesh}}\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh:nirfasterff-base-fluor-mesh}}\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh::doc}}\index{module@\spxentry{module}!nirfasterff.base.fluor\_mesh@\spxentry{nirfasterff.base.fluor\_mesh}}\index{nirfasterff.base.fluor\_mesh@\spxentry{nirfasterff.base.fluor\_mesh}!module@\spxentry{module}}
\sphinxAtStartPar
Define the fluorescence mesh class
\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fluormesh}}}}}()
&
\sphinxAtStartPar
Main class for fluorescence mesh.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.base.fluor\_mesh.fluormesh}
\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff-base-fluor-mesh-fluormesh}}\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh::doc}}\index{fluormesh (class in nirfasterff.base.fluor\_mesh)@\spxentry{fluormesh}\spxextra{class in nirfasterff.base.fluor\_mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.fluor\_mesh.}}\sphinxbfcode{\sphinxupquote{fluormesh}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Main class for fluorescence mesh. The methods should cover most of the commonly\sphinxhyphen{}used functionalities
\index{name (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{name}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.name}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
name of the mesh. Default: ‘EmptyMesh’
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{nodes (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{nodes}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.nodes}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{nodes}}}
\pysigstopsignatures
\sphinxAtStartPar
locations of nodes in the mesh. Unit: mm. Size (NNodes, dim)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{bndvtx (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{bndvtx}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.bndvtx}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{bndvtx}}}
\pysigstopsignatures
\sphinxAtStartPar
indicator of whether a node is at boundary (1) or internal (0). Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{type (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{type}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.type}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{type}}}
\pysigstopsignatures
\sphinxAtStartPar
type of the mesh. It is always ‘fluor’.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{muax (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{muax}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.muax}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{muax}}}
\pysigstopsignatures
\sphinxAtStartPar
intrisic absorption coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at excitation wavelength at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{muam (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{muam}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.muam}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{muam}}}
\pysigstopsignatures
\sphinxAtStartPar
intrisic absorption coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at emission wavelength at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{muaf (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{muaf}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.muaf}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{muaf}}}
\pysigstopsignatures
\sphinxAtStartPar
intrisic absorption coefficient (mm\textasciicircum{}\sphinxhyphen{}1) of the fluorophores at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{kappax (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{kappax}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.kappax}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{kappax}}}
\pysigstopsignatures
\sphinxAtStartPar
intrisic diffusion coefficient (mm) at excitation wavelength at each node. Size (NNodes,). Defined as 1/(3*(muax + musx))
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{kappam (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{kappam}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.kappam}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{kappam}}}
\pysigstopsignatures
\sphinxAtStartPar
intrisic diffusion coefficient (mm) at emission wavelength at each node. Size (NNodes,). Defined as 1/(3*(muam + musm))
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{ri (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{ri}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.ri}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{ri}}}
\pysigstopsignatures
\sphinxAtStartPar
refractive index at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{musx (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{musx}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.musx}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{musx}}}
\pysigstopsignatures
\sphinxAtStartPar
intrisic reduced scattering coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at excitation wavelength at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{musm (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{musm}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.musm}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{musm}}}
\pysigstopsignatures
\sphinxAtStartPar
intrisic reduced scattering coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at emission wavelength at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{eta (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{eta}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.eta}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{eta}}}
\pysigstopsignatures
\sphinxAtStartPar
quantum efficiency (a.u.) of the fluorophores. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{tau (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{tau}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.tau}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{tau}}}
\pysigstopsignatures
\sphinxAtStartPar
time coefficient (second) of the fluorophores. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{elements (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{elements}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.elements}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{elements}}}
\pysigstopsignatures
\sphinxAtStartPar
triangulation (tetrahedrons or triangles) of the mesh, Size (NElements, dim+1)

\sphinxAtStartPar
Row i contains the indices of the nodes that form tetrahedron/triangle i

\sphinxAtStartPar
One\sphinxhyphen{}based indexing for direct interoperatability with the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{region (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{region}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.region}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{region}}}
\pysigstopsignatures
\sphinxAtStartPar
region labeling of each node. Starting from 1. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{source (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{source}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.source}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{source}}}
\pysigstopsignatures
\sphinxAtStartPar
information about the sources
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.optode

\end{description}\end{quote}

\end{fulllineitems}

\index{meas (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{meas}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.meas}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{meas}}}
\pysigstopsignatures
\sphinxAtStartPar
information about the the detectors
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.optode

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{link}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
list of source\sphinxhyphen{}detector pairs, i.e. channels. Size (NChannels,3)

\sphinxAtStartPar
First column: source; Second column: detector; Third column: active (1) or not (0)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{c (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{c}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.c}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{c}}}
\pysigstopsignatures
\sphinxAtStartPar
light speed (mm/sec) at each node.  Size (NNodes,). Defined as c0/ri, where c0 is the light speed in vacuum
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{ksi (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{ksi}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.ksi}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{ksi}}}
\pysigstopsignatures
\sphinxAtStartPar
photon fluence rate scale factor on the mesh\sphinxhyphen{}outside\_mesh boundary as derived from Fresenel’s law. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{element\_area (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{element\_area}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.element_area}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{element\_area}}}
\pysigstopsignatures
\sphinxAtStartPar
volume/area (mm\textasciicircum{}3 or mm\textasciicircum{}2) of each element. Size (NElements,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{support (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{support}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.support}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{support}}}
\pysigstopsignatures
\sphinxAtStartPar
total volume/area of all the elements each node belongs to. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.fluor\_mesh.fluormesh attribute)@\spxentry{vol}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
object holding information for converting between mesh and volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.change_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{change\_prop}}}}}(idx, prop)
&
\sphinxAtStartPar
Change optical properties (muax, musxp, ri, muam, musmp, muaf, eta, and tau) at nodes specified in idx, and automatically change fields kappax, kappam, c, and ksi as well
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.femdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata}}}}}(freq{[}, solver, opt, xflag, mmflag, ...{]})
&
\sphinxAtStartPar
Calculates fluences for each source using a FEM solver, and then the boudary measurables for each channel
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.femdata_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_moments}}}}}({[}max\_moments, savefield, ...{]})
&
\sphinxAtStartPar
Calculates TR moments at each location in the mesh for each source directly using Mellin transform, and then the boudary measurables for each channel
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.femdata_tpsf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_tpsf}}}}}(tmax, dt{[}, savefield, ...{]})
&
\sphinxAtStartPar
Calculates TPSF at each location in the mesh for each source using a FEM solver, and then the boudary measurables for each channel
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_copy}}}}}(mesh)
&
\sphinxAtStartPar
Deep copy all fields from another mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_file}}}}}(file)
&
\sphinxAtStartPar
Read from classic NIRFAST mesh (ASCII) format, not checking the correctness of the loaded integration functions.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_mat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_mat}}}}}(matfile{[}, varname{]})
&
\sphinxAtStartPar
Read from Matlab .mat file that contains a NIRFASTer mesh struct.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_solid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_solid}}}}}(ele, nodes{[}, prop, src, det, link{]})
&
\sphinxAtStartPar
Construct a NIRFASTer mesh from a 3D solid mesh generated by a mesher.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_volume}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_volume}}}}}(vol{[}, param, prop, src, det, link{]})
&
\sphinxAtStartPar
Construct mesh from a segmented 3D volume using the built\sphinxhyphen{}in CGAL mesher.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.gen_intmat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_intmat}}}}}(xgrid, ygrid{[}, zgrid{]})
&
\sphinxAtStartPar
Calculate the information needed to convert data between mesh and volumetric space, specified by x, y, z (if 3D) grids.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Check if convertion matrices between mesh and volumetric spaces are calculated
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.jacobian}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian}}}}}({[}freq, normalize, solver, opt{]})
&
\sphinxAtStartPar
Calculates the Jacobian matrix
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.save_nirfast}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{save\_nirfast}}}}}(filename)
&
\sphinxAtStartPar
Save mesh in the classic NIRFASTer ASCII format, which is directly compatible with the Matlab version
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop}}}}}(prop)
&
\sphinxAtStartPar
Set optical properties of the whole mesh, using information provided in prop.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.touch_optodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_optodes}}}}}()
&
\sphinxAtStartPar
Moves all optodes (if non fixed) and recalculate the integration functions (i.e. barycentric coordinates).
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{change\_prop() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{change\_prop()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.change_prop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{change\_prop}}}
{\sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Change optical properties (muax, musxp, ri, muam, musmp, muaf, eta, and tau) at nodes specified in idx, and automatically change fields kappax, kappam, c, and ksi as well
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{}1}}) \textendash{} zero\sphinxhyphen{}based indices of nodes to change. If \sphinxtitleref{idx==\sphinxhyphen{}1}, function changes all the nodes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{length 8}}) \textendash{} new optical properties to be assigned to the specified nodes. {[}muax(mm\sphinxhyphen{}1) musxp(mm\sphinxhyphen{}1) ri muam(mm\sphinxhyphen{}1) musmp(mm\sphinxhyphen{}1) muaf(mm\sphinxhyphen{}1) eta tau(sec){]}.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{femdata() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{femdata()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.femdata}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{femdata}}}
{\sphinxparam{\DUrole{n}{freq}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xflag}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mmflag}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{flflag}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates fluences for each source using a FEM solver, and then the boudary measurables for each channel

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set, fluence data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_CW:nirfasterff.forward.femdata.femdata_fl_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_CW()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_FD:nirfasterff.forward.femdata.femdata_fl_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_FD()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} modulation frequency in Hz. If CW, set to zero and a more efficient CW solver will be used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if intrinsic excitation field is calculated. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mmflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if intrinsic emission field is calculated. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{flflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if fluorescence field is calculated. If set True, xflag must also be True. The default is True.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} fluence and boundary measurables given the mesh and optodes.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FLdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infox} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for intrinsic excitation.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infom} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for intrinsic emission.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infofl} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for fluorescence emission.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{femdata\_moments() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{femdata\_moments()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.femdata_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{femdata\_moments}}}
{\sphinxparam{\DUrole{n}{max\_moments}\DUrole{o}{=}\DUrole{default_value}{3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates TR moments at each location in the mesh for each source directly using Mellin transform, and then the boudary measurables for each channel

\sphinxAtStartPar
This is done for both excitation and fluorescence emission

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set and \sphinxtitleref{savefield} is set to \sphinxtitleref{True}, internal moments data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR_moments:nirfasterff.forward.femdata.femdata_fl_TR_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_TR\_moments()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_moments}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} max order of moments to calculate. That is, 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th will be calculated. The default is 3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal moments are also returned. If False, only boundary moments are returned and data.phix and data.phifl will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.flTRMomentsdata}) \textendash{} internal and boundary moments given the mesh and optodes, both excitation and fluorescence emission.

\sphinxAtStartPar
See \sphinxcode{\sphinxupquote{flTRMomentsdata()}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infox} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, excitation.

\sphinxAtStartPar
Only the convergence info of highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infom} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, fluorescence emission.

\sphinxAtStartPar
Only the convergence info of highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{femdata\_tpsf() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{femdata\_tpsf()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.femdata_tpsf}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{femdata\_tpsf}}}
{\sphinxparam{\DUrole{n}{tmax}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{beautify}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates TPSF at each location in the mesh for each source using a FEM solver, and then the boudary measurables for each channel

\sphinxAtStartPar
This is done for both excitation and fluorescence emission

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set and \sphinxtitleref{savefield} is set to \sphinxtitleref{True}, internal TPSF data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR:nirfasterff.forward.femdata.femdata_fl_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_TR()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tmax}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} maximum time simulated, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} size of each time step, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal TPSFs are also returned. If False, only boundary TPSFs are returned and data.phix and data.phifl will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beautify}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If true, zeros the initial unstable parts of the boundary TPSFs. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.flTPSFdata}) \textendash{} internal and boundary TPSFs given the mesh and optodes, both excitation and fluorescence emission.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flTPSFdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infox} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, excitation.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infom} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, fluorescence emission.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{from\_copy() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{from\_copy()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_copy}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_copy}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Deep copy all fields from another mesh.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} the mesh to copy from.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_file() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{from\_file()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_file}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_file}}}
{\sphinxparam{\DUrole{n}{file}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Read from classic NIRFAST mesh (ASCII) format, not checking the correctness of the loaded integration functions.

\sphinxAtStartPar
All fields after loading should be directly compatible with Matlab version.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the mesh. Any extension will be ignored.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{nirfasterff}\PYG{o}{.}\PYG{n}{base}\PYG{o}{.}\PYG{n}{fluormesh}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{meshname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{from\_mat() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{from\_mat()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_mat}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_mat}}}
{\sphinxparam{\DUrole{n}{matfile}}\sphinxparamcomma \sphinxparam{\DUrole{n}{varname}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Read from Matlab .mat file that contains a NIRFASTer mesh struct. All fields copied as is without error checking.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{matfile}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the .mat file to load. Use of extension is optional.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
if your .mat file contains multiple variables, use this argument to specify which one to load. The default is None.

\sphinxAtStartPar
When \sphinxtitleref{varname==None}, \sphinxtitleref{matfile} should contain exatly one structure, which is a NIRFASTer mesh, or the function will do nothing


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_solid() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{from\_solid()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_solid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_solid}}}
{\sphinxparam{\DUrole{n}{ele}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{src}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{det}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{link}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Construct a NIRFASTer mesh from a 3D solid mesh generated by a mesher. Similar to the solidmesh2nirfast function in Matlab version.

\sphinxAtStartPar
Can also set the optical properties and optodes if supplied
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int/double NumPy array}}) \textendash{} 
\sphinxAtStartPar
element list in one\sphinxhyphen{}based indexing. If four columns, all nodes will be labeled as region 1

\sphinxAtStartPar
If five columns, the last column will be used for region labeling.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations in the mesh. Unit: mm. Size (NNodes,3).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, calls \sphinxtitleref{fluormesh.set\_prop()} and sets the optical properties in the mesh. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{src}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the sources and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{det}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the detectors and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{link}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the channel information. Uses one\sphinxhyphen{}based indexing. The default is None.

\sphinxAtStartPar
Each row represents a channel, in the form of \sphinxtitleref{{[}src, det, active{]}}, where \sphinxtitleref{active} is 0 or 1

\sphinxAtStartPar
If \sphinxtitleref{link} contains only two columns, all channels are considered active.


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_volume() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{from\_volume()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.from_volume}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_volume}}}
{\sphinxparam{\DUrole{n}{vol}}\sphinxparamcomma \sphinxparam{\DUrole{n}{param}\DUrole{o}{=}\DUrole{default_value}{utils.MeshingParams()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{src}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{det}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{link}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Construct mesh from a segmented 3D volume using the built\sphinxhyphen{}in CGAL mesher. Calls fluormesh.from\_solid after meshing step.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vol}} (\sphinxstyleliteralemphasis{\sphinxupquote{uint8 NumPy array}}) \textendash{} 3D segmented volume to be meshed. 0 is considered as outside. Regions labeled using unique integers.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.MeshingParams}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
parameters used in the CGAL mesher. If not specified, uses the default parameters defined in nirfasterff.utils.MeshingParams().

\sphinxAtStartPar
Please modify fields xPixelSpacing, yPixelSpacing, and SliceThickness if your volume doesn’t have {[}1,1,1{]} resolution

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshingParams()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, calls \sphinxtitleref{fluormesh.set\_prop()} and sets the optical properties in the mesh. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{src}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the sources and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{det}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the detectors and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{link}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the channel information. Uses one\sphinxhyphen{}based indexing. The default is None.

\sphinxAtStartPar
Each row represents a channel, in the form of \sphinxtitleref{{[}src, det, active{]}}, where \sphinxtitleref{active} is 0 or 1

\sphinxAtStartPar
If \sphinxtitleref{link} contains only two columns, all channels are considered active.


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_intmat() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{gen\_intmat()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.gen_intmat}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{gen\_intmat}}}
{\sphinxparam{\DUrole{n}{xgrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ygrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zgrid}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the information needed to convert data between mesh and volumetric space, specified by x, y, z (if 3D) grids.

\sphinxAtStartPar
All grids must be uniform. The results will from a nirfasterff.base.meshvol object stored in field .vol

\sphinxAtStartPar
If field .vol already exists, it will be calculated again, and a warning will be thrown
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} x grid in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ygrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} x grid in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} x grid in mm. Leave empty for 2D meshes. The default is {[}{]}.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if grids not uniform, or zgrid empty for 3D mesh

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{isvol() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{isvol()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Check if convertion matrices between mesh and volumetric spaces are calculated
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if attribute \sphinxtitleref{.vol} is calculate, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{jacobian() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{jacobian()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.jacobian}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{jacobian}}}
{\sphinxparam{\DUrole{n}{freq}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the Jacobian matrix

\sphinxAtStartPar
Returns the Jacobian, direct field data, and the adjoint data

\sphinxAtStartPar
Structure of the Jacobian is detailed in {\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_CW:nirfasterff.inverse.jacobian_fl_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_fl\_CW()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_FD:nirfasterff.inverse.jacobian_fl_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_fl\_FD()}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} modulation frequency in Hz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
whether normalize the Jacobian to the amplitudes of boundary measurements at excitation wavelength (‘Born ratio’).

\sphinxAtStartPar
The default is True.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if modulation frequency is negative.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel, NVoxel*2) or (NChannel, NVoxel)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(freq)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(freq) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{save\_nirfast() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{save\_nirfast()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.save_nirfast}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{save\_nirfast}}}
{\sphinxparam{\DUrole{n}{filename}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Save mesh in the classic NIRFASTer ASCII format, which is directly compatible with the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the file to be saved as. Should have no extensions.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_prop() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{set\_prop()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.set_prop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{set\_prop}}}
{\sphinxparam{\DUrole{n}{prop}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Set optical properties of the whole mesh, using information provided in prop.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} 
\sphinxAtStartPar
optical property info, similar to the MCX format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{region} \PYG{n}{muax}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musxp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{ri} \PYG{n}{muam}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musmp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{muaf}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{eta} \PYG{n}{tau}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{region} \PYG{n}{muax}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musxp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{ri} \PYG{n}{muam}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musmp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{muaf}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{eta} \PYG{n}{tau}\PYG{p}{]}
\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where ‘region’ is the region label, and they should match exactly with unique(mesh.region). The order doesn’t matter.


\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{touch\_optodes() (nirfasterff.base.fluor\_mesh.fluormesh method)@\spxentry{touch\_optodes()}\spxextra{nirfasterff.base.fluor\_mesh.fluormesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.fluor_mesh.fluormesh:nirfasterff.base.fluor_mesh.fluormesh.touch_optodes}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{touch\_optodes}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Moves all optodes (if non fixed) and recalculate the integration functions (i.e. barycentric coordinates).

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.base.optodes}
\label{\detokenize{_autosummary/nirfasterff.base.optodes:module-nirfasterff.base.optodes}}\label{\detokenize{_autosummary/nirfasterff.base.optodes:nirfasterff-base-optodes}}\label{\detokenize{_autosummary/nirfasterff.base.optodes::doc}}\index{module@\spxentry{module}!nirfasterff.base.optodes@\spxentry{nirfasterff.base.optodes}}\index{nirfasterff.base.optodes@\spxentry{nirfasterff.base.optodes}!module@\spxentry{module}}
\sphinxAtStartPar
Define the optode class, an instance of which can be either a source or a detector
\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{optode}}}}}({[}coord{]})
&
\sphinxAtStartPar
Class for NIRFASTer optodes, which can be either a group of sources or a group of detectors.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.base.optodes.optode}
\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff-base-optodes-optode}}\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode::doc}}\index{optode (class in nirfasterff.base.optodes)@\spxentry{optode}\spxextra{class in nirfasterff.base.optodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.optodes.}}\sphinxbfcode{\sphinxupquote{optode}}}
{\sphinxparam{\DUrole{n}{coord}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class for NIRFASTer optodes, which can be either a group of sources or a group of detectors.

\sphinxAtStartPar
Note: The field fwhm for sources in the Matlab version has been dropped.
\index{fixed (nirfasterff.base.optodes.optode attribute)@\spxentry{fixed}\spxextra{nirfasterff.base.optodes.optode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.fixed}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{fixed}}}
\pysigstopsignatures
\sphinxAtStartPar
whether an optode is fixed.

\sphinxAtStartPar
If not, it will be moved to one scattering length inside the surface (source) or on the surface (detector).

\sphinxAtStartPar
Default: 0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
bool like

\end{description}\end{quote}

\end{fulllineitems}

\index{num (nirfasterff.base.optodes.optode attribute)@\spxentry{num}\spxextra{nirfasterff.base.optodes.optode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.num}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{num}}}
\pysigstopsignatures
\sphinxAtStartPar
indexing of the optodes, starting from one (1,2,3,…)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}

\end{fulllineitems}

\index{coord (nirfasterff.base.optodes.optode attribute)@\spxentry{coord}\spxextra{nirfasterff.base.optodes.optode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.coord}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{coord}}}
\pysigstopsignatures
\sphinxAtStartPar
each row is the location of an optode. Unit: mm
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{int\_func (nirfasterff.base.optodes.optode attribute)@\spxentry{int\_func}\spxextra{nirfasterff.base.optodes.optode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.int_func}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{int\_func}}}
\pysigstopsignatures
\sphinxAtStartPar
First column is the index (one\sphinxhyphen{}based) of the element each optode is in.

\sphinxAtStartPar
The subsequent columns are the barycentric coordinates (i.e. integration function) in the correponding elements. Size (N, dim+2).
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.optodes.optode method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.optodes.optode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{\sphinxparam{\DUrole{n}{coord}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}({[}coord{]})
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.move_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{move\_detectors}}}}}(mesh)
&
\sphinxAtStartPar
Moves detector to the appropriate locations in the mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.move_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{move\_sources}}}}}(mesh)
&
\sphinxAtStartPar
Moves sources to the appropriate locations in the mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors}}}}}(mesh)
&
\sphinxAtStartPar
Recalculate/fill in all other fields based on \textquotesingle{}fixed\textquotesingle{} and \textquotesingle{}coord\textquotesingle{}.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources}}}}}(mesh)
&
\sphinxAtStartPar
Recalculate/fill in all other fields based on \textquotesingle{}fixed\textquotesingle{} and \textquotesingle{}coord\textquotesingle{}.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{move\_detectors() (nirfasterff.base.optodes.optode method)@\spxentry{move\_detectors()}\spxextra{nirfasterff.base.optodes.optode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.move_detectors}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{move\_detectors}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Moves detector to the appropriate locations in the mesh.

\sphinxAtStartPar
For each detector, first move it to the closest point on the surface of the mesh.

\sphinxAtStartPar
Integration functions are NOT calculated after moving, to be consistent with the Matlab version.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{NIRFASTer mesh type}}) \textendash{} The mesh on which the detectors are installed. Can be a ‘stndmesh’, ‘fluormesh’, or ‘dcsmesh’, either 2D or 3D

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If mesh.elements does not have 3 or 4 columns, or mesh.dimension is not 2 or 3.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{move\_sources() (nirfasterff.base.optodes.optode method)@\spxentry{move\_sources()}\spxextra{nirfasterff.base.optodes.optode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.move_sources}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{move\_sources}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Moves sources to the appropriate locations in the mesh.

\sphinxAtStartPar
For each source, first move it to the closest point on the surface of the mesh, and then move inside by one scattering length along surface normal.

\sphinxAtStartPar
where scattering length is \(1/\mu_s'\) for stnd and dcs mesh, and \(1/\mu_{sx}'\) for fluor mesh

\sphinxAtStartPar
Integration functions are also calculated after moving.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{NIRFASTer mesh type}}) \textendash{} The mesh on which the sources are installed. Can be a ‘stndmesh’, ‘fluormesh’, or ‘dcsmesh’, either 2D or 3D

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If mesh type is not recognized.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If mesh.elements does not have 3 or 4 columns, or mesh.dimension is not 2 or 3.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{touch\_detectors() (nirfasterff.base.optodes.optode method)@\spxentry{touch\_detectors()}\spxextra{nirfasterff.base.optodes.optode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{touch\_detectors}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Recalculate/fill in all other fields based on ‘fixed’ and ‘coord’.

\sphinxAtStartPar
This is useful when a set of detectors are manually added and only the locations are specified.

\sphinxAtStartPar
For non\sphinxhyphen{}fixed detectors, function ‘move\_detectors’ is first called, and integration functions are calculated subsequentely.

\sphinxAtStartPar
For fixed detectors, recalculates integration functions directly.

\sphinxAtStartPar
If no detector locations are specified, the function does nothing
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{NIRFASTer mesh type}}) \textendash{} The mesh on which the sources are installed. Can be a ‘stndmesh’, ‘fluormesh’, or ‘dcsmesh’, either 2D or 3D

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{touch\_sources() (nirfasterff.base.optodes.optode method)@\spxentry{touch\_sources()}\spxextra{nirfasterff.base.optodes.optode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{touch\_sources}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Recalculate/fill in all other fields based on ‘fixed’ and ‘coord’.

\sphinxAtStartPar
This is useful when a set of sources are manually added and only the locations are specified.

\sphinxAtStartPar
For non\sphinxhyphen{}fixed sources, function ‘move\_sources’ is called, otherwise recalculates integration functions directly

\sphinxAtStartPar
If no source locations are specified, the function does nothing
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{NIRFASTer mesh type}}) \textendash{} The mesh on which the sources are installed. Can be a ‘stndmesh’, ‘fluormesh’, or ‘dcsmesh’, either 2D or 3D

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.base.stnd\_mesh}
\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh:module-nirfasterff.base.stnd_mesh}}\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh:nirfasterff-base-stnd-mesh}}\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh::doc}}\index{module@\spxentry{module}!nirfasterff.base.stnd\_mesh@\spxentry{nirfasterff.base.stnd\_mesh}}\index{nirfasterff.base.stnd\_mesh@\spxentry{nirfasterff.base.stnd\_mesh}!module@\spxentry{module}}
\sphinxAtStartPar
Define the standard mesh class
\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{stndmesh}}}}}()
&
\sphinxAtStartPar
Main class for standard mesh.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.base.stnd\_mesh.stndmesh}
\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff-base-stnd-mesh-stndmesh}}\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh::doc}}\index{stndmesh (class in nirfasterff.base.stnd\_mesh)@\spxentry{stndmesh}\spxextra{class in nirfasterff.base.stnd\_mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.base.stnd\_mesh.}}\sphinxbfcode{\sphinxupquote{stndmesh}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Main class for standard mesh. The methods should cover most of the commonly\sphinxhyphen{}used functionalities
\index{name (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{name}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.name}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{name}}}
\pysigstopsignatures
\sphinxAtStartPar
name of the mesh. Default: ‘EmptyMesh’
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{nodes (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{nodes}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.nodes}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{nodes}}}
\pysigstopsignatures
\sphinxAtStartPar
locations of nodes in the mesh. Unit: mm. Size (NNodes, dim)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{bndvtx (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{bndvtx}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.bndvtx}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{bndvtx}}}
\pysigstopsignatures
\sphinxAtStartPar
indicator of whether a node is at boundary (1) or internal (0). Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{type (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{type}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.type}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{type}}}
\pysigstopsignatures
\sphinxAtStartPar
type of the mesh. It is always ‘stnd’.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{mua (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{mua}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.mua}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{mua}}}
\pysigstopsignatures
\sphinxAtStartPar
absorption coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{kappa (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{kappa}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.kappa}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{kappa}}}
\pysigstopsignatures
\sphinxAtStartPar
diffusion coefficient (mm) at each node. Size (NNodes,). Defined as 1/(3*(mua + mus))
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{ri (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{ri}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.ri}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{ri}}}
\pysigstopsignatures
\sphinxAtStartPar
refractive index at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{mus (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{mus}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.mus}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{mus}}}
\pysigstopsignatures
\sphinxAtStartPar
reduced scattering coefficient (mm\textasciicircum{}\sphinxhyphen{}1) at each node. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
(double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{elements (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{elements}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.elements}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{elements}}}
\pysigstopsignatures
\sphinxAtStartPar
triangulation (tetrahedrons or triangles) of the mesh, Size (NElements, dim+1)

\sphinxAtStartPar
Row i contains the indices of the nodes that form tetrahedron/triangle i

\sphinxAtStartPar
One\sphinxhyphen{}based indexing for direct interoperatability with the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{region (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{region}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.region}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{region}}}
\pysigstopsignatures
\sphinxAtStartPar
region labeling of each node. Starting from 1. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{source (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{source}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.source}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{source}}}
\pysigstopsignatures
\sphinxAtStartPar
information about the sources
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.optode

\end{description}\end{quote}

\end{fulllineitems}

\index{meas (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{meas}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.meas}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{meas}}}
\pysigstopsignatures
\sphinxAtStartPar
information about the the detectors
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.optode

\end{description}\end{quote}

\end{fulllineitems}

\index{link (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{link}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.link}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{link}}}
\pysigstopsignatures
\sphinxAtStartPar
list of source\sphinxhyphen{}detector pairs, i.e. channels. Size (NChannels,3)

\sphinxAtStartPar
First column: source; Second column: detector; Third column: active (1) or not (0)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int32 NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{c (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{c}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.c}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{c}}}
\pysigstopsignatures
\sphinxAtStartPar
light speed (mm/sec) at each node.  Size (NNodes,). Defined as c0/ri, where c0 is the light speed in vacuum
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{ksi (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{ksi}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.ksi}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{ksi}}}
\pysigstopsignatures
\sphinxAtStartPar
photon fluence rate scale factor on the mesh\sphinxhyphen{}outside\_mesh boundary as derived from Fresenel’s law. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{element\_area (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{element\_area}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.element_area}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{element\_area}}}
\pysigstopsignatures
\sphinxAtStartPar
volume/area (mm\textasciicircum{}3 or mm\textasciicircum{}2) of each element. Size (NElements,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{support (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{support}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.support}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{support}}}
\pysigstopsignatures
\sphinxAtStartPar
total volume/area of all the elements each node belongs to. Size (NNodes,)
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\index{vol (nirfasterff.base.stnd\_mesh.stndmesh attribute)@\spxentry{vol}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.vol}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{vol}}}
\pysigstopsignatures
\sphinxAtStartPar
object holding information for converting between mesh and volumetric space.
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
nirfasterff.base.meshvol

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.change_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{change\_prop}}}}}(idx, prop)
&
\sphinxAtStartPar
Change optical properties (mua, musp, and ri) at nodes specified in idx, and automatically change fields kappa, c, and ksi as well
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.femdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata}}}}}(freq{[}, solver, opt{]})
&
\sphinxAtStartPar
Calculates fluences for each source using a FEM solver, and then the boudary measurables for each channel
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.femdata_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_moments}}}}}({[}max\_moments, savefield, ...{]})
&
\sphinxAtStartPar
Calculates TR moments at each location in the mesh for each source directly using Mellin transform, and then the boudary measurables for each channel
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.femdata_tpsf}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_tpsf}}}}}(tmax, dt{[}, savefield, ...{]})
&
\sphinxAtStartPar
Calculates TPSF at each location in the mesh for each source using a FEM solver, and then the boudary measurables for each channel
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_copy}}}}}(mesh)
&
\sphinxAtStartPar
Deep copy all fields from another mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_file}}}}}(file)
&
\sphinxAtStartPar
Read from classic NIRFAST mesh (ASCII) format, not checking the correctness of the loaded integration functions.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_mat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_mat}}}}}(matfile{[}, varname{]})
&
\sphinxAtStartPar
Read from Matlab .mat file that contains a NIRFASTer mesh struct.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_solid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_solid}}}}}(ele, nodes{[}, prop, src, det, link{]})
&
\sphinxAtStartPar
Construct a NIRFASTer mesh from a 3D solid mesh generated by a mesher.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_volume}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_volume}}}}}(vol{[}, param, prop, src, det, link{]})
&
\sphinxAtStartPar
Construct mesh from a segmented 3D volume using the built\sphinxhyphen{}in CGAL mesher.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.gen_intmat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_intmat}}}}}(xgrid, ygrid{[}, zgrid{]})
&
\sphinxAtStartPar
Calculate the information needed to convert data between mesh and volumetric space, specified by x, y, z (if 3D) grids.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.isvol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isvol}}}}}()
&
\sphinxAtStartPar
Check if convertion matrices between mesh and volumetric spaces are calculated
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.jacobian}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian}}}}}({[}freq, normalize, mus, solver, opt{]})
&
\sphinxAtStartPar
Calculates the Jacobian matrix
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.save_nirfast}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{save\_nirfast}}}}}(filename)
&
\sphinxAtStartPar
Save mesh in the classic NIRFASTer ASCII format, which is directly compatible with the Matlab version
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop}}}}}(prop)
&
\sphinxAtStartPar
Set optical properties of the whole mesh, using information provided in prop.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.touch_optodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_optodes}}}}}()
&
\sphinxAtStartPar
Moves all optodes (if non fixed) and recalculate the integration functions (i.e. barycentric coordinates).
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{change\_prop() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{change\_prop()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.change_prop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{change\_prop}}}
{\sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Change optical properties (mua, musp, and ri) at nodes specified in idx, and automatically change fields kappa, c, and ksi as well
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{}1}}) \textendash{} zero\sphinxhyphen{}based indices of nodes to change. If \sphinxtitleref{idx==\sphinxhyphen{}1}, function changes all the nodes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{length 3}}) \textendash{} new optical properties to be assigned to the specified nodes. {[}mua(mm\sphinxhyphen{}1) musp(mm\sphinxhyphen{}1) ri{]}.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{femdata() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{femdata()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.femdata}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{femdata}}}
{\sphinxparam{\DUrole{n}{freq}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates fluences for each source using a FEM solver, and then the boudary measurables for each channel

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set, fluence data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_CW:nirfasterff.forward.femdata.femdata_stnd_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_CW()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_FD:nirfasterff.forward.femdata.femdata_stnd_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_FD()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} modulation frequency in Hz. If CW, set to zero and a more efficient CW solver will be used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} fluence and boundary measurables given the mesh and optodes.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FDdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{femdata\_moments() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{femdata\_moments()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.femdata_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{femdata\_moments}}}
{\sphinxparam{\DUrole{n}{max\_moments}\DUrole{o}{=}\DUrole{default_value}{3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates TR moments at each location in the mesh for each source directly using Mellin transform, and then the boudary measurables for each channel

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set and \sphinxtitleref{savefield} is set to \sphinxtitleref{True}, internal moments data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR_moments:nirfasterff.forward.femdata.femdata_stnd_TR_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_TR\_moments()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_moments}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} max order of moments to calculate. That is, 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th will be calculated. The default is 3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal moments are also returned. If False, only boundary moments are returned and data.phi will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.TRMomentsdata}) \textendash{} internal and boundary moments given the mesh and optodes.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TRMomentsdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{femdata\_tpsf() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{femdata\_tpsf()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.femdata_tpsf}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{femdata\_tpsf}}}
{\sphinxparam{\DUrole{n}{tmax}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{beautify}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates TPSF at each location in the mesh for each source using a FEM solver, and then the boudary measurables for each channel

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set and \sphinxtitleref{savefield} is set to \sphinxtitleref{True}, internal TPSF data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR:nirfasterff.forward.femdata.femdata_stnd_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_TR()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tmax}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} maximum time simulated, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} size of each time step, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal TPSFs are also returned. If False, only boundary TPSFs are returned and data.phi will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beautify}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If true, zeros the initial unstable parts of the boundary TPSFs. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.TPSFdata}) \textendash{} internal and boundary TPSFs given the mesh and optodes.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TPSFdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{from\_copy() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{from\_copy()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_copy}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_copy}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Deep copy all fields from another mesh.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh to copy from.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_file() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{from\_file()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_file}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_file}}}
{\sphinxparam{\DUrole{n}{file}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Read from classic NIRFAST mesh (ASCII) format, not checking the correctness of the loaded integration functions.

\sphinxAtStartPar
All fields after loading should be directly compatible with Matlab version.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the mesh. Any extension will be ignored.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{nirfasterff}\PYG{o}{.}\PYG{n}{base}\PYG{o}{.}\PYG{n}{stndmesh}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{meshname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{from\_mat() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{from\_mat()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_mat}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_mat}}}
{\sphinxparam{\DUrole{n}{matfile}}\sphinxparamcomma \sphinxparam{\DUrole{n}{varname}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Read from Matlab .mat file that contains a NIRFASTer mesh struct. All fields copied as is without error checking.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{matfile}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the .mat file to load. Use of extension is optional.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
if your .mat file contains multiple variables, use this argument to specify which one to load. The default is None.

\sphinxAtStartPar
When \sphinxtitleref{varname==None}, \sphinxtitleref{matfile} should contain exatly one structure, which is a NIRFASTer mesh, or the function will do nothing


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_solid() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{from\_solid()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_solid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_solid}}}
{\sphinxparam{\DUrole{n}{ele}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{src}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{det}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{link}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Construct a NIRFASTer mesh from a 3D solid mesh generated by a mesher. Similar to the solidmesh2nirfast function in Matlab version.

\sphinxAtStartPar
Can also set the optical properties and optodes if supplied
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int/double NumPy array}}) \textendash{} 
\sphinxAtStartPar
element list in one\sphinxhyphen{}based indexing. If four columns, all nodes will be labeled as region 1

\sphinxAtStartPar
If five columns, the last column will be used for region labeling.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations in the mesh. Unit: mm. Size (NNodes,3).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, calls \sphinxtitleref{stndmesh.set\_prop()} and sets the optical properties in the mesh. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{src}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the sources and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{det}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the detectors and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{link}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the channel information. Uses one\sphinxhyphen{}based indexing. The default is None.

\sphinxAtStartPar
Each row represents a channel, in the form of \sphinxtitleref{{[}src, det, active{]}}, where \sphinxtitleref{active} is 0 or 1

\sphinxAtStartPar
If \sphinxtitleref{link} contains only two columns, all channels are considered active.


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_volume() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{from\_volume()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.from_volume}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{from\_volume}}}
{\sphinxparam{\DUrole{n}{vol}}\sphinxparamcomma \sphinxparam{\DUrole{n}{param}\DUrole{o}{=}\DUrole{default_value}{utils.MeshingParams()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{prop}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{src}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{det}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{link}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Construct mesh from a segmented 3D volume using the built\sphinxhyphen{}in CGAL mesher. Calls stndmesh.from\_solid after meshing step.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vol}} (\sphinxstyleliteralemphasis{\sphinxupquote{uint8 NumPy array}}) \textendash{} 3D segmented volume to be meshed. 0 is considered as outside. Regions labeled using unique integers.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.MeshingParams}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
parameters used in the CGAL mesher. If not specified, uses the default parameters defined in nirfasterff.utils.MeshingParams().

\sphinxAtStartPar
Please modify fields xPixelSpacing, yPixelSpacing, and SliceThickness if your volume doesn’t have {[}1,1,1{]} resolution

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshingParams()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, calls \sphinxtitleref{stndmesh.set\_prop()} and sets the optical properties in the mesh. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.set_prop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_prop()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{src}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the sources and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{det}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.optode}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the detectors and moves them to the appropriate locations. The default is None.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{link}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If not \sphinxtitleref{None}, sets the channel information. Uses one\sphinxhyphen{}based indexing. The default is None.

\sphinxAtStartPar
Each row represents a channel, in the form of \sphinxtitleref{{[}src, det, active{]}}, where \sphinxtitleref{active} is 0 or 1

\sphinxAtStartPar
If \sphinxtitleref{link} contains only two columns, all channels are considered active.


\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_intmat() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{gen\_intmat()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.gen_intmat}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{gen\_intmat}}}
{\sphinxparam{\DUrole{n}{xgrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ygrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zgrid}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the information needed to convert data between mesh and volumetric space, specified by x, y, z (if 3D) grids.

\sphinxAtStartPar
All grids must be uniform. The results will from a nirfasterff.base.meshvol object stored in field .vol

\sphinxAtStartPar
If field .vol already exists, it will be calculated again, and a warning will be thrown
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} x grid in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ygrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} x grid in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} x grid in mm. Leave empty for 2D meshes. The default is {[}{]}.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if grids not uniform, or zgrid empty for 3D mesh

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{isvol() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{isvol()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.isvol}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{isvol}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Check if convertion matrices between mesh and volumetric spaces are calculated
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if attribute \sphinxtitleref{.vol} is calculate, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{jacobian() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{jacobian()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.jacobian}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{jacobian}}}
{\sphinxparam{\DUrole{n}{freq}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mus}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the Jacobian matrix

\sphinxAtStartPar
Returns the Jacobian, direct field data, and the adjoint data

\sphinxAtStartPar
Structure of the Jacobian is detailed in {\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_CW:nirfasterff.inverse.jacobian_stnd_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_stnd\_CW()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_FD:nirfasterff.inverse.jacobian_stnd_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_stnd\_FD()}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} modulation frequency, in Hz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
whether normalize the Jacobian to the amplitudes of boundary measurements, i.e. use Rytov approximation.

\sphinxAtStartPar
The default is True.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mus}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether derivates wrt mus (left half of the ‘full’ Jacobian) is calculated. Only has effect when freq=0. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if freq is negative.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double or complex double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel*2, NVoxel*2) if freq\textgreater{}0, (NChannel, NVoxel*2) if freq=0 and mus=True, (NChannel, NVoxel) if freq=0 and mus=False

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(freq)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(freq) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{save\_nirfast() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{save\_nirfast()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.save_nirfast}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{save\_nirfast}}}
{\sphinxparam{\DUrole{n}{filename}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Save mesh in the classic NIRFASTer ASCII format, which is directly compatible with the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the file to be saved as. Should have no extensions.

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_prop() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{set\_prop()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.set_prop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{set\_prop}}}
{\sphinxparam{\DUrole{n}{prop}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Set optical properties of the whole mesh, using information provided in prop.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{prop}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} 
\sphinxAtStartPar
optical property info, similar to the MCX format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{region} \PYG{n}{mua}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{ri}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{region} \PYG{n}{mua}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{musp}\PYG{p}{(}\PYG{n}{mm}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{ri}\PYG{p}{]}
\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where ‘region’ is the region label, and they should match exactly with unique(mesh.region). The order doesn’t matter.


\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{touch\_optodes() (nirfasterff.base.stnd\_mesh.stndmesh method)@\spxentry{touch\_optodes()}\spxextra{nirfasterff.base.stnd\_mesh.stndmesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.base.stnd_mesh.stndmesh:nirfasterff.base.stnd_mesh.stndmesh.touch_optodes}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{touch\_optodes}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Moves all optodes (if non fixed) and recalculate the integration functions (i.e. barycentric coordinates).

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_sources()}}}}} and {\hyperref[\detokenize{_autosummary/nirfasterff.base.optodes.optode:nirfasterff.base.optodes.optode.touch_detectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{touch\_detectors()}}}}} for details
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.forward}
\label{\detokenize{_autosummary/nirfasterff.forward:module-nirfasterff.forward}}\label{\detokenize{_autosummary/nirfasterff.forward:nirfasterff-forward}}\label{\detokenize{_autosummary/nirfasterff.forward::doc}}\index{module@\spxentry{module}!nirfasterff.forward@\spxentry{nirfasterff.forward}}\index{nirfasterff.forward@\spxentry{nirfasterff.forward}!module@\spxentry{module}}
\sphinxAtStartPar
Funtions for forward data calculation
\subsubsection*{Modules}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.analytical:module-nirfasterff.forward.analytical}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{analytical}}}}}
&
\sphinxAtStartPar
Analytical solutions to the diffusion equation in semi\sphinxhyphen{}infinite media
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata:module-nirfasterff.forward.femdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata}}}}}
&
\sphinxAtStartPar
The FEM solvers.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.forward.analytical}
\label{\detokenize{_autosummary/nirfasterff.forward.analytical:module-nirfasterff.forward.analytical}}\label{\detokenize{_autosummary/nirfasterff.forward.analytical:nirfasterff-forward-analytical}}\label{\detokenize{_autosummary/nirfasterff.forward.analytical::doc}}\index{module@\spxentry{module}!nirfasterff.forward.analytical@\spxentry{nirfasterff.forward.analytical}}\index{nirfasterff.forward.analytical@\spxentry{nirfasterff.forward.analytical}!module@\spxentry{module}}
\sphinxAtStartPar
Analytical solutions to the diffusion equation in semi\sphinxhyphen{}infinite media
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_CW:nirfasterff.forward.analytical.semi_infinite_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{semi\_infinite\_CW}}}}}(mua, musp, n, rho{[}, z, ...{]})
&
\sphinxAtStartPar
Calculates the continuous\sphinxhyphen{}wave fluence in space using the analytical solution to the diffusion equation in semi\sphinxhyphen{}infinite media.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_DCS:nirfasterff.forward.analytical.semi_infinite_DCS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{semi\_infinite\_DCS}}}}}(mua, musp, n, rho, aDb, ...)
&
\sphinxAtStartPar
Calculates DCS G1 curve using the analytical solution to the correlation diffusion equation in semi\sphinxhyphen{}infinite media
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_FD:nirfasterff.forward.analytical.semi_infinite_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{semi\_infinite\_FD}}}}}(mua, musp, n, freq, rho{[}, ...{]})
&
\sphinxAtStartPar
Calculates the frequency\sphinxhyphen{}domain fluence in space using the analytical solution to the diffusion equation in semi\sphinxhyphen{}infinite media.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_TR:nirfasterff.forward.analytical.semi_infinite_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{semi\_infinite\_TR}}}}}(mua, musp, n, rho, T, dt{[}, ...{]})
&
\sphinxAtStartPar
Calculates TPSF at a given location using the analytical solution to the diffusion equation in semi\sphinxhyphen{}infinite media
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.forward.analytical.semi\_infinite\_CW}
\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_CW:nirfasterff-forward-analytical-semi-infinite-cw}}\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_CW::doc}}\index{semi\_infinite\_CW() (in module nirfasterff.forward.analytical)@\spxentry{semi\_infinite\_CW()}\spxextra{in module nirfasterff.forward.analytical}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_CW:nirfasterff.forward.analytical.semi_infinite_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.analytical.}}\sphinxbfcode{\sphinxupquote{semi\_infinite\_CW}}}
{\sphinxparam{\DUrole{n}{mua}}\sphinxparamcomma \sphinxparam{\DUrole{n}{musp}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rho}}\sphinxparamcomma \sphinxparam{\DUrole{n}{z}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}exact\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_air}\DUrole{o}{=}\DUrole{default_value}{1.0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the continuous\sphinxhyphen{}wave fluence in space using the analytical solution to the diffusion equation in semi\sphinxhyphen{}infinite media.

\sphinxAtStartPar
Internaly calls the FD version with freq set to zero
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mua}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} absorption coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{musp}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} reduced scattering coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} refractive index of the medium.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} 
\sphinxAtStartPar
distance to the light source, projected to the x\sphinxhyphen{}y (i.e. boundary plane of the semi\sphinxhyphen{}infinite space) plane, in mm.

\sphinxAtStartPar
Can be a vector, in which case fluences calculated at multiple locations will be returned


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
depth of the location(s) of interest. 0 for boundary measurement.

\sphinxAtStartPar
If a vector, it must have the same length as rho

\sphinxAtStartPar
The default is 0.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{boundary}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
type of the boundary condition, which can be ‘robin’, ‘approx’, or ‘exact’. The default is ‘exact’.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation:nirfasterff.utils.boundary_attenuation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{boundary\_attenuation()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_air}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} refratcive index outside of the semi\sphinxhyphen{}infinite space, which is typically assumed to be air. The default is 1.0.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
calculated fluence, where each element corresponds to a location, as specified by rho and z. Size (NLocation,)

\sphinxlineitem{Return type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Durduran et al, 2010, Rep. Prog. Phys. doi:10.1088/0034\sphinxhyphen{}4885/73/7/076701

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.analytical.semi\_infinite\_DCS}
\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_DCS:nirfasterff-forward-analytical-semi-infinite-dcs}}\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_DCS::doc}}\index{semi\_infinite\_DCS() (in module nirfasterff.forward.analytical)@\spxentry{semi\_infinite\_DCS()}\spxextra{in module nirfasterff.forward.analytical}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_DCS:nirfasterff.forward.analytical.semi_infinite_DCS}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.analytical.}}\sphinxbfcode{\sphinxupquote{semi\_infinite\_DCS}}}
{\sphinxparam{\DUrole{n}{mua}}\sphinxparamcomma \sphinxparam{\DUrole{n}{musp}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rho}}\sphinxparamcomma \sphinxparam{\DUrole{n}{aDb}}\sphinxparamcomma \sphinxparam{\DUrole{n}{wvlength}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{z}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}exact\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_air}\DUrole{o}{=}\DUrole{default_value}{1.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates DCS G1 curve using the analytical solution to the correlation diffusion equation in semi\sphinxhyphen{}infinite media

\sphinxAtStartPar
Function assumes Brownian motion, that is, \(\langle\Delta r^2\rangle=6\alpha Db\tau\)
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mua}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} absorption coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{musp}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} reduced scattering coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} refractive index of the medium.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} distance to the light source, projected to the x\sphinxhyphen{}y (i.e. boundary plane of the semi\sphinxhyphen{}infinite space) plane, in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{aDb}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} The lumped flow parameter \(\alpha Db\) in Brownian motion.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wvlength}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} wavelength used, in nm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double Numpy vector}}) \textendash{} time vector used to calculate the G1 curve. It is usually a good idea to use log space.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} depth of the location of interest. 0 for boundary measurement. The default is 0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{boundary}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
type of the boundary condition, which can be ‘robin’, ‘approx’, or ‘exact’. The default is ‘exact’.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation:nirfasterff.utils.boundary_attenuation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{boundary\_attenuation()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_air}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} refratcive index outside of the semi\sphinxhyphen{}infinite space, which is typically assumed to be air. The default is 1.0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if true, returns the normalized g1 curve, instead of G1. The default is 0.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
G1 or g1 curve calculated at the given location and time points.

\sphinxlineitem{Return type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Durduran et al, 2010, Rep. Prog. Phys. doi:10.1088/0034\sphinxhyphen{}4885/73/7/076701

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.analytical.semi\_infinite\_FD}
\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_FD:nirfasterff-forward-analytical-semi-infinite-fd}}\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_FD::doc}}\index{semi\_infinite\_FD() (in module nirfasterff.forward.analytical)@\spxentry{semi\_infinite\_FD()}\spxextra{in module nirfasterff.forward.analytical}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_FD:nirfasterff.forward.analytical.semi_infinite_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.analytical.}}\sphinxbfcode{\sphinxupquote{semi\_infinite\_FD}}}
{\sphinxparam{\DUrole{n}{mua}}\sphinxparamcomma \sphinxparam{\DUrole{n}{musp}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}\sphinxparamcomma \sphinxparam{\DUrole{n}{freq}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rho}}\sphinxparamcomma \sphinxparam{\DUrole{n}{z}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}exact\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_air}\DUrole{o}{=}\DUrole{default_value}{1.0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the frequency\sphinxhyphen{}domain fluence in space using the analytical solution to the diffusion equation in semi\sphinxhyphen{}infinite media.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mua}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} absorption coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{musp}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} reduced scattering coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} refractive index of the medium.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} modulation frequency, in Hz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} 
\sphinxAtStartPar
distance to the light source, projected to the x\sphinxhyphen{}y (i.e. boundary plane of the semi\sphinxhyphen{}infinite space) plane, in mm.

\sphinxAtStartPar
Can be a vector, in which case fluences calculated at multiple locations will be returned


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
depth of the location(s) of interest. 0 for boundary measurement.

\sphinxAtStartPar
If a vector, it must have the same length as rho

\sphinxAtStartPar
The default is 0.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{boundary}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
type of the boundary condition, which can be ‘robin’, ‘approx’, or ‘exact’. The default is ‘exact’.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation:nirfasterff.utils.boundary_attenuation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{boundary\_attenuation()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_air}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} refratcive index outside of the semi\sphinxhyphen{}infinite space, which is typically assumed to be air. The default is 1.0.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar

\sphinxAtStartPar
calculated complex fluence, where each row (or element in vector) corresponds to a location, as specified by rho and z,

\sphinxAtStartPar
and each column corresponds to a modulation frequency. Size (NLocation,), or (NLocation, NFreq)


\sphinxlineitem{Return type}
\sphinxAtStartPar
complex double NumPy array

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Durduran et al, 2010, Rep. Prog. Phys. doi:10.1088/0034\sphinxhyphen{}4885/73/7/076701

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.analytical.semi\_infinite\_TR}
\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_TR:nirfasterff-forward-analytical-semi-infinite-tr}}\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_TR::doc}}\index{semi\_infinite\_TR() (in module nirfasterff.forward.analytical)@\spxentry{semi\_infinite\_TR()}\spxextra{in module nirfasterff.forward.analytical}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.analytical.semi_infinite_TR:nirfasterff.forward.analytical.semi_infinite_TR}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.analytical.}}\sphinxbfcode{\sphinxupquote{semi\_infinite\_TR}}}
{\sphinxparam{\DUrole{n}{mua}}\sphinxparamcomma \sphinxparam{\DUrole{n}{musp}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rho}}\sphinxparamcomma \sphinxparam{\DUrole{n}{T}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}}\sphinxparamcomma \sphinxparam{\DUrole{n}{z}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}EBC\sphinxhyphen{}Robin\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates TPSF at a given location using the analytical solution to the diffusion equation in semi\sphinxhyphen{}infinite media
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mua}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} absorption coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{musp}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} reduced scattering coefficient of the medium, in mm\textasciicircum{}\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} refractive index of the medium.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} distance to the light source, projected to the x\sphinxhyphen{}y (i.e. boundary plane of the semi\sphinxhyphen{}infinite space) plane, in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} 
\sphinxAtStartPar
if a scalar, it is the total amount of time and time vector will be generated also based on dt (see below).

\sphinxAtStartPar
if a vector, it is directly used as the time vector, and the argument dt will be ignored. Unit: seconds


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} step size of the time vector (in seconds). If the argument T is a vector, it will be ignored.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
depth of the location of interest. 0 for boundary measurement. The default is 0.

\sphinxAtStartPar
Note that when \sphinxtitleref{z=0}, the function returns reflectance, instead of fluence. Please refer to the References for detail.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{boundary}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
type of the boundary condition, which can be (case insensitive),

\sphinxAtStartPar
’PCB\sphinxhyphen{}exact’ \sphinxhyphen{} partial current boundary condition, with exact internal reflectance

\sphinxAtStartPar
’PCB\sphinxhyphen{}approx’ \sphinxhyphen{} partial current boundary condition, with Groenhuis internal reflectance approximation

\sphinxAtStartPar
’PCB\sphinxhyphen{}Robin’ \sphinxhyphen{} partial current boundary condition, with internal reflectance derived from Fresnel’s law

\sphinxAtStartPar
’EBC\sphinxhyphen{}exact’ \sphinxhyphen{} extrapolated boundary condition, with exact internal reflectance

\sphinxAtStartPar
’EBC\sphinxhyphen{}approx’ \sphinxhyphen{} extrapolated boundary condition, with Groenhuis internal reflectance approximation

\sphinxAtStartPar
’EBC\sphinxhyphen{}Robin’ \sphinxhyphen{} extrapolated boundary condition, with internal reflectance derived from Fresnel’s law

\sphinxAtStartPar
’ZBC’ \sphinxhyphen{} zero boundary condition

\sphinxAtStartPar
The default is ‘EBC\sphinxhyphen{}Robin’.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation:nirfasterff.utils.boundary_attenuation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{boundary\_attenuation()}}}}} for the differences between ‘exact’, ‘approx’ and ‘robin’


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if boundary condition is not of a recognized kind.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{phi} \textendash{} Coumn 0: the time vector; Column 1: calculated TPSF at the given location. Size (NTime, 2)

\sphinxlineitem{Return type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Hielscher et al., 1995, Phys. Med. Biol. doi:10.1088/0031\sphinxhyphen{}9155/40/11/013

\sphinxAtStartPar
Kienle and Patterson, 1997, JOSA A. doi:10.1364/JOSAA.14.000246

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.forward.femdata}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata:module-nirfasterff.forward.femdata}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata:nirfasterff-forward-femdata}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata::doc}}\index{module@\spxentry{module}!nirfasterff.forward.femdata@\spxentry{nirfasterff.forward.femdata}}\index{nirfasterff.forward.femdata@\spxentry{nirfasterff.forward.femdata}!module@\spxentry{module}}
\sphinxAtStartPar
The FEM solvers. It is usually recommended to use the high\sphinxhyphen{}level wrappers in the mesh classes by calling the mesh.femdata* functions.
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_DCS:nirfasterff.forward.femdata.femdata_DCS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_DCS}}}}}(mesh, tvec{[}, solver, opt{]})
&
\sphinxAtStartPar
Forward modeling calculating steady\sphinxhyphen{}state fluences and G1/g1 curves by solving the correlation diffusion equation.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_CW:nirfasterff.forward.femdata.femdata_fl_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_CW}}}}}(mesh{[}, solver, opt, xflag, ...{]})
&
\sphinxAtStartPar
Forward modeling for CW in fluorescence meshes.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_FD:nirfasterff.forward.femdata.femdata_fl_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_FD}}}}}(mesh, freq{[}, solver, opt, ...{]})
&
\sphinxAtStartPar
Forward modeling for FD in fluorescence meshes.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR:nirfasterff.forward.femdata.femdata_fl_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_TR}}}}}(mesh, tmax, dt{[}, savefield, ...{]})
&
\sphinxAtStartPar
Forward modeling calculating TPSF on a fluorescence mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR_moments:nirfasterff.forward.femdata.femdata_fl_TR_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_fl\_TR\_moments}}}}}(mesh{[}, max\_moments, ...{]})
&
\sphinxAtStartPar
Forward modeling calculating TR moments using Mellin transform on a fluorescence mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_CW:nirfasterff.forward.femdata.femdata_stnd_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_CW}}}}}(mesh{[}, solver, opt{]})
&
\sphinxAtStartPar
Forward modeling for CW.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_FD:nirfasterff.forward.femdata.femdata_stnd_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_FD}}}}}(mesh, freq{[}, solver, opt{]})
&
\sphinxAtStartPar
Forward modeling for FD.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR:nirfasterff.forward.femdata.femdata_stnd_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_TR}}}}}(mesh, tmax, dt{[}, savefield, ...{]})
&
\sphinxAtStartPar
Forward modeling calculating TPSF on a standard mesh.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR_moments:nirfasterff.forward.femdata.femdata_stnd_TR_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{femdata\_stnd\_TR\_moments}}}}}(mesh{[}, max\_moments, ...{]})
&
\sphinxAtStartPar
Forward modeling calculating TR moments using Mellin transform on a standard mesh.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_DCS}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_DCS:nirfasterff-forward-femdata-femdata-dcs}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_DCS::doc}}\index{femdata\_DCS() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_DCS()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_DCS:nirfasterff.forward.femdata.femdata_DCS}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_DCS}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling calculating steady\sphinxhyphen{}state fluences and G1/g1 curves by solving the correlation diffusion equation. Please consider using mesh.femdata(tvec) instead.

\sphinxAtStartPar
The fluences as well as its boundary amplitudes are exactly the same as what the CW solver would give when tau=0.

\sphinxAtStartPar
g1 curve is simple G1 curve normalized by the boundary amplitudes.

\sphinxAtStartPar
The function calculates the MASS matrices, the source vectors, and calls the G1 solver, which internally utilizes the CW solver.

\sphinxAtStartPar
When calculating the flow\sphinxhyphen{}related term, the function assumes Brownian motion and uses only mesh.aDb (that is, mesh.a and mesh.Db are ignored).

\sphinxAtStartPar
This is to say, we assume \(\langle\Delta r^2\rangle=6\alpha Db\tau\)
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.dcsmesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} time vector (i.e. :math:\textasciigrave{}       au\textasciigrave{}) for the G1 curve, in seconds. It is usually a good idea to use log scale

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a dcs mesh.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.DCSdata}) \textendash{} contains fluence, G1 curve, and g1 curve calculated at each spatial location, and also the boundary data.

\sphinxAtStartPar
If mesh.vol is set, internal G1 curves will be returned in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.DCSdata:nirfasterff.base.data.DCSdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DCSdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver when calculating the fluence field.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_CW:nirfasterff.math.get_field_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_CW()}}}}}


\end{sphinxseealso}

\subsubsection*{References}

\sphinxAtStartPar
Durduran et al, 2010, Rep. Prog. Phys. doi:10.1088/0034\sphinxhyphen{}4885/73/7/076701

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_fl\_CW}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_CW:nirfasterff-forward-femdata-femdata-fl-cw}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_CW::doc}}\index{femdata\_fl\_CW() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_fl\_CW()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_CW:nirfasterff.forward.femdata.femdata_fl_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_fl\_CW}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xflag}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mmflag}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{flflag}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling for CW in fluorescence meshes. Please consider using mesh.femdata(0) instead.

\sphinxAtStartPar
The function calculates the MASS matrices, the source vectors, and calls the CW solver (preconditioned conjugated gradient).

\sphinxAtStartPar
The optional flags can be used to determine which fields are calculated. By default all true.

\sphinxAtStartPar
Note that when flflag is set to True, xflag must also be True.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if intrinsic excitation field is calculated. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mmflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if intrinsic emission field is calculated. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{flflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if fluorescence field is calculated. If set True, xflag must also be True. The default is True.

\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If mesh is not a fluor mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If flflag is set True but xflag is not.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} fluence and boundary measurables given the mesh and optodes.

\sphinxAtStartPar
If mesh.vol is defined, the returned fluences will be in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FLdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infox} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for intrinsic excitation.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infom} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for intrinsic emission.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infofl} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for fluorescence emission.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_CW:nirfasterff.math.get_field_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_CW()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources_fl:nirfasterff.math.gen_sources_fl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources\_fl()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_fl\_FD}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_FD:nirfasterff-forward-femdata-femdata-fl-fd}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_FD::doc}}\index{femdata\_fl\_FD() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_fl\_FD()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_FD:nirfasterff.forward.femdata.femdata_fl_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_fl\_FD}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{freq}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xflag}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mmflag}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{flflag}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling for FD in fluorescence meshes. Please consider using mesh.femdata(frequency) instead.

\sphinxAtStartPar
The function calculates the MASS matrix, the source vectors, and calls the FD solver (preconditioned BiCGStab).

\sphinxAtStartPar
The optional flags can be used to determine which fields are calculated. By default all true.

\sphinxAtStartPar
Note that when flflag is set to True, xflag must also be True.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} 
\sphinxAtStartPar
modulation frequency in Hz.

\sphinxAtStartPar
When it is 0, function continues with the BiCGstab solver, but generates a warning that the CW solver should be used for better performance


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if intrinsic excitation field is calculated. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mmflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if intrinsic emission field is calculated. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{flflag}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if fluorescence field is calculated. If set True, xflag must also be True. The default is True.

\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If mesh is not a fluor mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If flflag is set True but xflag is not.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} fluence and boundary measurables given the mesh and optodes.

\sphinxAtStartPar
If mesh.vol is defined, the returned fluences will be in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FLdata:nirfasterff.base.data.FLdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FLdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infox} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for intrinsic excitation.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infom} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for intrinsic emission.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infofl} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, for fluorescence emission.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_FD:nirfasterff.math.get_field_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_FD()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources_fl:nirfasterff.math.gen_sources_fl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources\_fl()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_fl\_TR}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR:nirfasterff-forward-femdata-femdata-fl-tr}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR::doc}}\index{femdata\_fl\_TR() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_fl\_TR()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR:nirfasterff.forward.femdata.femdata_fl_TR}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_fl\_TR}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tmax}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{beautify}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling calculating TPSF on a fluorescence mesh. Please consider using mesh.femdata\_tpsf(tmax, dt) instead.

\sphinxAtStartPar
The function calculates the MASS matrices, the source vectors, and calls two separate TPSF solvers (both preconditioned conjugated gradient):

\sphinxAtStartPar
First time calculates the TPSF for the excitation field, the result of which is consequently convolved with the decay.

\sphinxAtStartPar
The second solver is called with the convolved excitation field as its input to calculate the TPSF for fluorescence emission.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tmax}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} maximum time simulated, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} size of each time step, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal TPSFs are also returned. If False, only boundary TPSFs are returned and data.phix and data.phifl will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beautify}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If true, zeros the initial unstable parts of the boundary TPSFs. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a fluor mesh.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.flTPSFdata}) \textendash{} internal and boundary TPSFs given the mesh and optodes, both excitation and fluorescence emission.

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set and \sphinxtitleref{savefield} is set to \sphinxtitleref{True}, internal TPSF data will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTPSFdata:nirfasterff.base.data.flTPSFdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flTPSFdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infox} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, excitation.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infom} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, fluorescence emission.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TR:nirfasterff.math.get_field_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRFL:nirfasterff.math.get_field_TRFL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFL()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_fl\_TR\_moments}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR_moments:nirfasterff-forward-femdata-femdata-fl-tr-moments}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR_moments::doc}}\index{femdata\_fl\_TR\_moments() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_fl\_TR\_moments()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_fl_TR_moments:nirfasterff.forward.femdata.femdata_fl_TR_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_fl\_TR\_moments}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_moments}\DUrole{o}{=}\DUrole{default_value}{3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling calculating TR moments using Mellin transform on a fluorescence mesh. Please consider using mesh.femdata\_moments() instead.

\sphinxAtStartPar
The function calculates the MASS matrix, the source vectors, and calls the two Mellin moments solver (both preconditioned conjugated gradient):

\sphinxAtStartPar
First time calculates the moments for the excitation field, the result of which is consequently used as the input of the second solver,

\sphinxAtStartPar
which calculates the moments of fluorescence emission based on the excitation moments

\sphinxAtStartPar
Calculates 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th moments directly without calculating TPSF first, and this is done for both excitation and fluorescence emission.

\sphinxAtStartPar
This is more efficient, if the time series are not of concern.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} the mesh used to calculate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_moments}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} max order of moments to calculate. That is, 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th will be calculated. The default is 3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal moments are also returned. If False, only boundary moments are returned and data.phix and data.phifl will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a fluor mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if max\_moments is negative.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.flTRMomentsdata}) \textendash{} internal and boundary moments given the mesh and optodes, both excitation and fluorescence emission.

\sphinxAtStartPar
If \sphinxtitleref{mesh.vol} is set and \sphinxtitleref{savefield} is set to \sphinxtitleref{True}, internal moments will be represented in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.flTRMomentsdata:nirfasterff.base.data.flTRMomentsdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flTRMomentsdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infox} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, excitation.

\sphinxAtStartPar
Only the convergence info of highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{infom} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver, fluorescence emission.

\sphinxAtStartPar
Only the convergence info of highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRmoments:nirfasterff.math.get_field_TRmoments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRmoments()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRFLmoments:nirfasterff.math.get_field_TRFLmoments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFLmoments()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_stnd\_CW}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_CW:nirfasterff-forward-femdata-femdata-stnd-cw}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_CW::doc}}\index{femdata\_stnd\_CW() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_stnd\_CW()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_CW:nirfasterff.forward.femdata.femdata_stnd_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_stnd\_CW}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling for CW. Please consider using mesh.femdata(0) instead.

\sphinxAtStartPar
The function calculates the FEM MASS matrix, the source vectors, and calls the CW solver (preconditioned conjugated gradient).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If mesh is not a stnd mesh.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} fluence and boundary measurables given the mesh and optodes.

\sphinxAtStartPar
If mesh.vol is defined, the returned fluence will be in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FDdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_CW:nirfasterff.math.get_field_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_CW()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_stnd\_FD}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_FD:nirfasterff-forward-femdata-femdata-stnd-fd}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_FD::doc}}\index{femdata\_stnd\_FD() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_stnd\_FD()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_FD:nirfasterff.forward.femdata.femdata_stnd_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_stnd\_FD}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{freq}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling for FD. Please consider using mesh.femdata(freq) instead. freq in Hz

\sphinxAtStartPar
The function calculates the MASS matrix, the source vectors, and calls the FD solver (preconditioned BiCGStab).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} 
\sphinxAtStartPar
modulation frequency in Hz.

\sphinxAtStartPar
When it is 0, function continues with the BiCGstab solver, but generates a warning that the CW solver should be used for better performance


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If mesh is not a stnd mesh.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} fluence and boundary measurables given the mesh and optodes.

\sphinxAtStartPar
If mesh.vol is defined, the returned fluence will be in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.FDdata:nirfasterff.base.data.FDdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FDdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_FD:nirfasterff.math.get_field_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_FD()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_stnd\_TR}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR:nirfasterff-forward-femdata-femdata-stnd-tr}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR::doc}}\index{femdata\_stnd\_TR() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_stnd\_TR()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR:nirfasterff.forward.femdata.femdata_stnd_TR}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_stnd\_TR}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tmax}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{beautify}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling calculating TPSF on a standard mesh. Please consider using mesh.femdata\_tpsf(tmax, dt) instead.

\sphinxAtStartPar
The function calculates the MASS matrices, the source vectors, and calls the standard TPSF solver (preconditioned conjugated gradient).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tmax}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} maximum time simulated, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} size of each time step, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal TPSFs are also returned. If False, only boundary TPSFs are returned and data.phi will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{beautify}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If true, zeros the initial unstable parts of the boundary TPSFs. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If mesh is not a stnd mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If tmax is smaller than dt

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.TPSFdata}) \textendash{} internal and boundary TPSFs given the mesh and optodes.

\sphinxAtStartPar
If mesh.vol is defined and \sphinxtitleref{savefield==True}, the returned internal TPSFs will be in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TPSFdata:nirfasterff.base.data.TPSFdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TPSFdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TR:nirfasterff.math.get_field_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.forward.femdata.femdata\_stnd\_TR\_moments}
\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR_moments:nirfasterff-forward-femdata-femdata-stnd-tr-moments}}\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR_moments::doc}}\index{femdata\_stnd\_TR\_moments() (in module nirfasterff.forward.femdata)@\spxentry{femdata\_stnd\_TR\_moments()}\spxextra{in module nirfasterff.forward.femdata}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.forward.femdata.femdata_stnd_TR_moments:nirfasterff.forward.femdata.femdata_stnd_TR_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.forward.femdata.}}\sphinxbfcode{\sphinxupquote{femdata\_stnd\_TR\_moments}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_moments}\DUrole{o}{=}\DUrole{default_value}{3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{savefield}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forward modeling calculating TR moments using Mellin transform on a standard mesh. Please consider using mesh.femdata\_moments() instead.

\sphinxAtStartPar
The function calculates the MASS matrices, the source vectors, and calls the Mellin moments solver (preconditioned conjugated gradient).

\sphinxAtStartPar
Calculates 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th moments directly without calculating TPSF first.

\sphinxAtStartPar
This is more efficient, if the actual TPSFs are not of concern.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh used to calcuate the forward data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_moments}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} max order of moments to calculate. That is, 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th will be calculated. The default is 3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{savefield}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
If True, the internal moments are also returned. If False, only boundary moments are returned and data.phi will be empty.

\sphinxAtStartPar
The default is False.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If mesh is not a stnd mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If max\_moments is negative.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{nirfasterff.base.TRMomentsdata}) \textendash{} internal and boundary moments given the mesh and optodes.

\sphinxAtStartPar
If mesh.vol is defined and \sphinxtitleref{savefield==True}, the returned internal moments will be in volumetric space

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.base.data.TRMomentsdata:nirfasterff.base.data.TRMomentsdata}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TRMomentsdata()}}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}}, and {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRmoments:nirfasterff.math.get_field_TRmoments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRmoments()}}}}}


\end{sphinxseealso}

\subsubsection*{References}

\sphinxAtStartPar
Arridge and Schweiger, Applied Optics, 1995. doi:10.1364/AO.34.002683

\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.inverse}
\label{\detokenize{_autosummary/nirfasterff.inverse:module-nirfasterff.inverse}}\label{\detokenize{_autosummary/nirfasterff.inverse:nirfasterff-inverse}}\label{\detokenize{_autosummary/nirfasterff.inverse::doc}}\index{module@\spxentry{module}!nirfasterff.inverse@\spxentry{nirfasterff.inverse}}\index{nirfasterff.inverse@\spxentry{nirfasterff.inverse}!module@\spxentry{module}}
\sphinxAtStartPar
Calculation of the Jacobian matrices and a basic Tikhonov regularization function
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_DCS:nirfasterff.inverse.jacobian_DCS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_DCS}}}}}(mesh, tvec{[}, normalize, ...{]})
&
\sphinxAtStartPar
Calculates the Jacobian matrix for a DCS mesh using the adjoint method
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_CW:nirfasterff.inverse.jacobian_fl_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_fl\_CW}}}}}(mesh{[}, normalize, solver, opt{]})
&
\sphinxAtStartPar
Calculates the continuous\sphinxhyphen{}wave fluorescence Jacobian matrix using the adjoint method
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_FD:nirfasterff.inverse.jacobian_fl_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_fl\_FD}}}}}(mesh, freq{[}, normalize, ...{]})
&
\sphinxAtStartPar
Calculates the frequency\sphinxhyphen{}domain fluorescence Jacobian matrix using the adjoint method
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_CW:nirfasterff.inverse.jacobian_stnd_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_stnd\_CW}}}}}(mesh{[}, normalize, mus, ...{]})
&
\sphinxAtStartPar
Calculates the continuous\sphinxhyphen{}wave Jacobian matrix using the adjoint method
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_FD:nirfasterff.inverse.jacobian_stnd_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_stnd\_FD}}}}}(mesh, freq{[}, normalize, ...{]})
&
\sphinxAtStartPar
Calculates the frequency\sphinxhyphen{}domain Jacobian matrix using the adjoint method
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.inverse.tikhonov:nirfasterff.inverse.tikhonov}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tikhonov}}}}}(A, reg, y)
&
\sphinxAtStartPar
Solves Tikhonov regularization (ie ridge regression)
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.inverse.jacobian\_DCS}
\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_DCS:nirfasterff-inverse-jacobian-dcs}}\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_DCS::doc}}\index{jacobian\_DCS() (in module nirfasterff.inverse)@\spxentry{jacobian\_DCS()}\spxextra{in module nirfasterff.inverse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_DCS:nirfasterff.inverse.jacobian_DCS}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.inverse.}}\sphinxbfcode{\sphinxupquote{jacobian\_DCS}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the Jacobian matrix for a DCS mesh using the adjoint method

\sphinxAtStartPar
One Jacobian is calcualted at each time point in tvec, and the derivative is taken with regard to aDb
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.dcsmesh}}) \textendash{} mesh on which the Jacobian is calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}) \textendash{} time vector used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True, Jacobbians are normalized to the measured boundary amplitude. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a DCS mesh, or mesh.vol is not defined.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel, NVoxel, NTime)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(tvec)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(tvec) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.inverse.jacobian\_fl\_CW}
\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_CW:nirfasterff-inverse-jacobian-fl-cw}}\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_CW::doc}}\index{jacobian\_fl\_CW() (in module nirfasterff.inverse)@\spxentry{jacobian\_fl\_CW()}\spxextra{in module nirfasterff.inverse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_CW:nirfasterff.inverse.jacobian_fl_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.inverse.}}\sphinxbfcode{\sphinxupquote{jacobian\_fl\_CW}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the continuous\sphinxhyphen{}wave fluorescence Jacobian matrix using the adjoint method

\sphinxAtStartPar
J\_\{ij\} = dA\_i / d\_gamma\_j

\sphinxAtStartPar
where A is fluorescence amplitude if normalization is False, fluorescence amplitude divided by excitation amplitude (‘Born ratio’) if True

\sphinxAtStartPar
gamma\_j = mesh.eta{[}j{]}*mesh.muaf{[}j{]}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh on which the Jacobian is calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
whether normalize the Jacobian to the amplitudes of boundary measurements at excitation wavelength (‘Born ratio’).

\sphinxAtStartPar
The default is True.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a fluor mesh, or mesh.vol is not defined.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel, NVoxel)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(0)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(0) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Milstein et al., JOSA A, 2004. doi:10.1364/JOSAA.21.001035

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.inverse.jacobian\_fl\_FD}
\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_FD:nirfasterff-inverse-jacobian-fl-fd}}\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_FD::doc}}\index{jacobian\_fl\_FD() (in module nirfasterff.inverse)@\spxentry{jacobian\_fl\_FD()}\spxextra{in module nirfasterff.inverse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_fl_FD:nirfasterff.inverse.jacobian_fl_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.inverse.}}\sphinxbfcode{\sphinxupquote{jacobian\_fl\_FD}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{freq}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the frequency\sphinxhyphen{}domain fluorescence Jacobian matrix using the adjoint method

\sphinxAtStartPar
The Jacobian is structured as, suppose we have M channels and N voxels:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}2}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{p}{[}\PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}real}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{d\PYGZus{}gamma\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}1}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{d\PYGZus{}imag}\PYG{p}{\PYGZob{}}\PYG{n}{A\PYGZus{}M}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{n}{dtau\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where A is fluorescence amplitude if normalization is False, fluorescence amplitude divided by excitation amplitude (‘Born ratio’) if True
gamma\_j = mesh.eta{[}j{]}*mesh.muaf{[}j{]}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh on which the Jacobian is calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} modulation frequency in Hz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
whether normalize the Jacobian to the amplitudes of boundary measurements at excitation wavelength (‘Born ratio’).

\sphinxAtStartPar
The default is True.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a fluor mesh, or mesh.vol is not defined.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel*2, NVoxel*2)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(freq)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FLdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(freq) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Milstein et al., JOSA A, 2004. doi:10.1364/JOSAA.21.001035

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.inverse.jacobian\_stnd\_CW}
\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_CW:nirfasterff-inverse-jacobian-stnd-cw}}\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_CW::doc}}\index{jacobian\_stnd\_CW() (in module nirfasterff.inverse)@\spxentry{jacobian\_stnd\_CW()}\spxextra{in module nirfasterff.inverse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_CW:nirfasterff.inverse.jacobian_stnd_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.inverse.}}\sphinxbfcode{\sphinxupquote{jacobian\_stnd\_CW}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mus}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the continuous\sphinxhyphen{}wave Jacobian matrix using the adjoint method

\sphinxAtStartPar
Calculates spatial distributions of sensitivity of field registerd on the mesh boundary to changes of optical properties per voxel.

\sphinxAtStartPar
When mus is set to True, the Jacobian is structured as, suppose we have M channels and N voxels:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{p}{[}\PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where A and Phi denote the measured amplitude and the phase if \sphinxtitleref{normalize=False}, and the log of them if \sphinxtitleref{normalize=True}

\sphinxAtStartPar
When mus is set to False, the returned Jacobian is only the right half of the above. That is, only derivatives wrt mua

\sphinxAtStartPar
Note that the calculation is only done in the volumetric space
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} mesh on which the Jacobian is calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
whether normalize the Jacobian to the amplitudes of boundary measurements, i.e. use Rytov approximation.

\sphinxAtStartPar
The default is True.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mus}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether derivates wrt mus (left half of the ‘full’ Jacobian) is calculated. The default is False.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a stnd mesh, or mesh.vol is not defined.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel, NVoxel*2) if mus=True, (NChannel, NVoxel) if mus=False

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(0)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(0) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.inverse.jacobian\_stnd\_FD}
\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_FD:nirfasterff-inverse-jacobian-stnd-fd}}\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_FD::doc}}\index{jacobian\_stnd\_FD() (in module nirfasterff.inverse)@\spxentry{jacobian\_stnd\_FD()}\spxextra{in module nirfasterff.inverse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_FD:nirfasterff.inverse.jacobian_stnd_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.inverse.}}\sphinxbfcode{\sphinxupquote{jacobian\_stnd\_FD}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{freq}}\sphinxparamcomma \sphinxparam{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mus}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the frequency\sphinxhyphen{}domain Jacobian matrix using the adjoint method

\sphinxAtStartPar
Calculates spatial distributions of sensitivity of field registerd on the mesh boundary to changes of optical properties per voxel.

\sphinxAtStartPar
When freq=0, see {\hyperref[\detokenize{_autosummary/nirfasterff.inverse.jacobian_stnd_CW:nirfasterff.inverse.jacobian_stnd_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{jacobian\_stnd\_CW()}}}}} for the structure of the Jacobian

\sphinxAtStartPar
When freq\textgreater{}0, the Jacobian is structured as, suppose we have M channels and N voxels:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{dPhi\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}1}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{dPhi\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}2}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{p}{[}\PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dA\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{dPhi\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}1}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmusp\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}1}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{dPhi\PYGZus{}M}\PYG{o}{/}\PYG{n}{dmua\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where A and Phi denote the measured amplitude and the phase if \sphinxtitleref{normalize=False}, and the log of them if \sphinxtitleref{normalize=True}

\sphinxAtStartPar
Note that the calculation is only done in the volumetric space
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} mesh on which the Jacobian is calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freq}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} modulation frequency, in Hz.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
whether normalize the Jacobian to the amplitudes of boundary measurements, i.e. use Rytov approximation.

\sphinxAtStartPar
The default is True.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mus}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether derivates wrt mus (left half of the ‘full’ Jacobian) is calculated. Only has effect when freq=0. The default is True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not a stnd mesh, or mesh.vol is not defined.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{J} (\sphinxstyleemphasis{double or complex double NumPy array}) \textendash{} The Jacobian matrix. Size (NChannel*2, NVoxel*2) if freq\textgreater{}0, (NChannel, NVoxel*2) if freq=0 and mus=True, (NChannel, NVoxel) if freq=0 and mus=False

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data1} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} The calculated direct field. The same as directly calling mesh.femdata(freq)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data2} (\sphinxstyleemphasis{nirfasterff.base.FDdata}) \textendash{} The calculated adjoint field. The same as calling mesh.femdata(freq) AFTER swapping the locations of sources and detectors

\end{itemize}


\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Arridge, Applied Optics, 1995. doi:10.1364/AO.34.007395

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.inverse.tikhonov}
\label{\detokenize{_autosummary/nirfasterff.inverse.tikhonov:nirfasterff-inverse-tikhonov}}\label{\detokenize{_autosummary/nirfasterff.inverse.tikhonov::doc}}\index{tikhonov() (in module nirfasterff.inverse)@\spxentry{tikhonov()}\spxextra{in module nirfasterff.inverse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.inverse.tikhonov:nirfasterff.inverse.tikhonov}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.inverse.}}\sphinxbfcode{\sphinxupquote{tikhonov}}}
{\sphinxparam{\DUrole{n}{A}}\sphinxparamcomma \sphinxparam{\DUrole{n}{reg}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Solves Tikhonov regularization (ie ridge regression)

\sphinxAtStartPar
That is, given a linear system y = Ax, it solves \(\arg\min_x ||Ax-y||_2^2+||\Gamma x||_2^2\)

\sphinxAtStartPar
where A is the forward matrix, y is the recording, and \(\Gamma\) is the regularization matrix
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} forward matrix, e.g. the Jacobian in DOT.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reg}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} 
\sphinxAtStartPar
if a scalar, the same regularization is applied to all elements of x, i.e. \(\Gamma=reg*I\).

\sphinxAtStartPar
if a vector, the regularization matrix is assumed to be diagonal, with the diagonal elements specified in reg, i.e. \(\Gamma=diag(reg)\).

\sphinxAtStartPar
if a matrix, it must be symmetric. In this case, \(\Gamma=reg\).


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}) \textendash{} measurement vector, e.g. dOD at each channel in DOT.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if reg is of incompatible size or not symmetric (if matrix).

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{result} \textendash{} Tikhonov regularized solution to the linear system.

\sphinxlineitem{Return type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.io}
\label{\detokenize{_autosummary/nirfasterff.io:module-nirfasterff.io}}\label{\detokenize{_autosummary/nirfasterff.io:nirfasterff-io}}\label{\detokenize{_autosummary/nirfasterff.io::doc}}\index{module@\spxentry{module}!nirfasterff.io@\spxentry{nirfasterff.io}}\index{nirfasterff.io@\spxentry{nirfasterff.io}!module@\spxentry{module}}
\sphinxAtStartPar
Some functions for reading/writing certain data types.

\sphinxAtStartPar
As of now, they are only used by the CGAL mesher, and there should be no need for the user to directly call them.
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.io.readMEDIT:nirfasterff.io.readMEDIT}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{readMEDIT}}}}}(fname)
&
\sphinxAtStartPar
Read a mesh generated by the CGAL mesher, which is saved in MEDIT format
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.io.saveinr:nirfasterff.io.saveinr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{saveinr}}}}}(vol, fname{[}, xPixelSpacing, ...{]})
&
\sphinxAtStartPar
Save a volume in the INRIA format.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.io.readMEDIT}
\label{\detokenize{_autosummary/nirfasterff.io.readMEDIT:nirfasterff-io-readmedit}}\label{\detokenize{_autosummary/nirfasterff.io.readMEDIT::doc}}\index{readMEDIT() (in module nirfasterff.io)@\spxentry{readMEDIT()}\spxextra{in module nirfasterff.io}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.io.readMEDIT:nirfasterff.io.readMEDIT}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.io.}}\sphinxbfcode{\sphinxupquote{readMEDIT}}}
{\sphinxparam{\DUrole{n}{fname}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Read a mesh generated by the CGAL mesher, which is saved in MEDIT format

\sphinxAtStartPar
Directly translated from the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the file to be loaded.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{elements} (\sphinxstyleemphasis{NumPy array}) \textendash{} list of elements in the mesh. Zero\sphinxhyphen{}based

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{nodes} (\sphinxstyleemphasis{NumPy array}) \textendash{} node locations of the mesh, in mm.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{faces} (\sphinxstyleemphasis{NumPy array}) \textendash{} list of faces in the mesh. In case of 2D, it’s the same as elements. Zero\sphinxhyphen{}based

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{nnpe} (\sphinxstyleemphasis{int}) \textendash{} size of dimension 1 of elements, i.e. 4 for 3D mesh and 3 for 2D mesh.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.io.saveinr}
\label{\detokenize{_autosummary/nirfasterff.io.saveinr:nirfasterff-io-saveinr}}\label{\detokenize{_autosummary/nirfasterff.io.saveinr::doc}}\index{saveinr() (in module nirfasterff.io)@\spxentry{saveinr()}\spxextra{in module nirfasterff.io}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.io.saveinr:nirfasterff.io.saveinr}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.io.}}\sphinxbfcode{\sphinxupquote{saveinr}}}
{\sphinxparam{\DUrole{n}{vol}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fname}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xPixelSpacing}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{yPixelSpacing}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{SliceThickness}\DUrole{o}{=}\DUrole{default_value}{1.}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Save a volume in the INRIA format. This is for the CGAL mesher.

\sphinxAtStartPar
Directly translated from the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vol}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} the volume to be saved.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file name to be saved as.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xPixelSpacing}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} volume resolution in x direction. The default is 1..

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{yPixelSpacing}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} volume resolution in y direction. The default is 1..

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{SliceThickness}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} volume resolution in z direction. The default is 1..

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.lib}
\label{\detokenize{_autosummary/nirfasterff.lib:module-nirfasterff.lib}}\label{\detokenize{_autosummary/nirfasterff.lib:nirfasterff-lib}}\label{\detokenize{_autosummary/nirfasterff.lib::doc}}\index{module@\spxentry{module}!nirfasterff.lib@\spxentry{nirfasterff.lib}}\index{nirfasterff.lib@\spxentry{nirfasterff.lib}!module@\spxentry{module}}
\sphinxAtStartPar
Low\sphinxhyphen{}level functions implemented in C/C++, on both GPU and CPU

\sphinxAtStartPar
You should NOT directly call these functions. Please use the wrapper functions provided instead
\subsubsection*{Modules}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu:module-nirfasterff.lib.nirfasterff_cpu}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nirfasterff\_cpu}}}}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda:module-nirfasterff.lib.nirfasterff_cuda}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nirfasterff\_cuda}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.lib.nirfasterff\_cpu}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu:module-nirfasterff.lib.nirfasterff_cpu}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu:nirfasterff-lib-nirfasterff-cpu}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu::doc}}\index{module@\spxentry{module}!nirfasterff.lib.nirfasterff\_cpu@\spxentry{nirfasterff.lib.nirfasterff\_cpu}}\index{nirfasterff.lib.nirfasterff\_cpu@\spxentry{nirfasterff.lib.nirfasterff\_cpu}!module@\spxentry{module}}\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGradGrid:nirfasterff.lib.nirfasterff_cpu.IntGradGrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IntGradGrid}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGrid:nirfasterff.lib.nirfasterff_cpu.IntGrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IntGrid}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ele_area:nirfasterff.lib.nirfasterff_cpu.ele_area}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ele\_area}}}}}(arg0, arg1)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_mass_matrix:nirfasterff.lib.nirfasterff_cpu.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix}}}}}(arg0, arg1, arg2, arg3, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_source_fl:nirfasterff.lib.nirfasterff_cpu.gen_source_fl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_source\_fl}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_CW:nirfasterff.lib.nirfasterff_cpu.get_field_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_CW}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_FD:nirfasterff.lib.nirfasterff_cpu.get_field_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_FD}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR:nirfasterff.lib.nirfasterff_cpu.get_field_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL:nirfasterff.lib.nirfasterff_cpu.get_field_TRFL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFL}}}}}(arg0, arg1, arg2, arg3, arg4, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL_moments:nirfasterff.lib.nirfasterff_cpu.get_field_TRFL_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFL\_moments}}}}}(arg0, arg1, arg2, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR_moments:nirfasterff.lib.nirfasterff_cpu.get_field_TR_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR\_moments}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc:nirfasterff.lib.nirfasterff_cpu.gradientIntfunc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gradientIntfunc}}}}}(arg0, arg1, arg2)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc2:nirfasterff.lib.nirfasterff_cpu.gradientIntfunc2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gradientIntfunc2}}}}}(arg0, arg1, arg2)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.isCUDA:nirfasterff.lib.nirfasterff_cpu.isCUDA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isCUDA}}}}}()
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.mesh_support:nirfasterff.lib.nirfasterff_cpu.mesh_support}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{mesh\_support}}}}}(arg0, arg1, arg2)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.pointLocation:nirfasterff.lib.nirfasterff_cpu.pointLocation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pointLocation}}}}}(arg0, arg1, arg2)
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.IntGradGrid}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGradGrid:nirfasterff-lib-nirfasterff-cpu-intgradgrid}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGradGrid::doc}}\index{IntGradGrid() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{IntGradGrid()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGradGrid:nirfasterff.lib.nirfasterff_cpu.IntGradGrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{IntGradGrid}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
IntGradGrid(arg0: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg3: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg4: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg5: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg6: numpy.ndarray{[}numpy.int32{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg7: int) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}

\item {} 
\sphinxAtStartPar
IntGradGrid(arg0: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg4: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg5: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg6: numpy.ndarray{[}numpy.int32{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg7: int) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.float64{[}m, n{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.IntGrid}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGrid:nirfasterff-lib-nirfasterff-cpu-intgrid}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGrid::doc}}\index{IntGrid() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{IntGrid()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.IntGrid:nirfasterff.lib.nirfasterff_cpu.IntGrid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{IntGrid}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
IntGrid(arg0: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.int32{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}

\item {} 
\sphinxAtStartPar
IntGrid(arg0: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.int32{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.float64{[}m, n{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.ele\_area}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ele_area:nirfasterff-lib-nirfasterff-cpu-ele-area}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ele_area::doc}}\index{ele\_area() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{ele\_area()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ele_area:nirfasterff.lib.nirfasterff_cpu.ele_area}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{ele\_area}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}}
{{ $\rightarrow$ numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.gen\_mass\_matrix}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_mass_matrix:nirfasterff-lib-nirfasterff-cpu-gen-mass-matrix}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_mass_matrix::doc}}\index{gen\_mass\_matrix() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{gen\_mass\_matrix()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_mass_matrix:nirfasterff.lib.nirfasterff_cpu.gen_mass_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{gen\_mass\_matrix}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg3}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg4}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg5}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg6}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg7}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }numpy.ndarray\DUrole{p}{{[}}numpy.complex128\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.gen\_source\_fl}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_source_fl:nirfasterff-lib-nirfasterff-cpu-gen-source-fl}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_source_fl::doc}}\index{gen\_source\_fl() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{gen\_source\_fl()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gen_source_fl:nirfasterff.lib.nirfasterff_cpu.gen_source_fl}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{gen\_source\_fl}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
gen\_source\_fl(arg0: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.float64{[}m, n{]}{]}

\item {} 
\sphinxAtStartPar
gen\_source\_fl(arg0: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.get\_field\_CW}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_CW:nirfasterff-lib-nirfasterff-cpu-get-field-cw}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_CW::doc}}\index{get\_field\_CW() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{get\_field\_CW()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_CW:nirfasterff.lib.nirfasterff_cpu.get_field_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{get\_field\_CW}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_CW(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: scipy.sparse.csc\_matrix{[}numpy.float64{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_CW(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.get\_field\_FD}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_FD:nirfasterff-lib-nirfasterff-cpu-get-field-fd}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_FD::doc}}\index{get\_field\_FD() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{get\_field\_FD()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_FD:nirfasterff.lib.nirfasterff_cpu.get_field_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{get\_field\_FD}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_FD(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.complex128{[}m, 1{]}, flags.writeable{]}, arg3: scipy.sparse.csc\_matrix{[}numpy.complex128{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_FD(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.complex128{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.get\_field\_TR}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR:nirfasterff-lib-nirfasterff-cpu-get-field-tr}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR::doc}}\index{get\_field\_TR() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{get\_field\_TR()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR:nirfasterff.lib.nirfasterff_cpu.get_field_TR}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{get\_field\_TR}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_TR(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: scipy.sparse.csc\_matrix{[}numpy.float64{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_TR(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.get\_field\_TRFL}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL:nirfasterff-lib-nirfasterff-cpu-get-field-trfl}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL::doc}}\index{get\_field\_TRFL() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{get\_field\_TRFL()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL:nirfasterff.lib.nirfasterff_cpu.get_field_TRFL}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{get\_field\_TRFL}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg3}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg4}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg5}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_iter}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{AbsoluteTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{RelativeTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{divergence}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{100000000.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nthread}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{8}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }list\DUrole{p}{{[}}{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU}]{\sphinxcrossref{nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.get\_field\_TRFL\_moments}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL_moments:nirfasterff-lib-nirfasterff-cpu-get-field-trfl-moments}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL_moments::doc}}\index{get\_field\_TRFL\_moments() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{get\_field\_TRFL\_moments()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TRFL_moments:nirfasterff.lib.nirfasterff_cpu.get_field_TRFL_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{get\_field\_TRFL\_moments}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg3}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg4}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg5}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg6}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg7}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg8}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_iter}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{AbsoluteTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{RelativeTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{divergence}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{100000000.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nthread}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{8}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }list\DUrole{p}{{[}}{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU}]{\sphinxcrossref{nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.get\_field\_TR\_moments}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR_moments:nirfasterff-lib-nirfasterff-cpu-get-field-tr-moments}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR_moments::doc}}\index{get\_field\_TR\_moments() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{get\_field\_TR\_moments()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.get_field_TR_moments:nirfasterff.lib.nirfasterff_cpu.get_field_TR_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{get\_field\_TR\_moments}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_TR\_moments(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: scipy.sparse.csc\_matrix{[}numpy.float64{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_TR\_moments(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, nthread: int = 8) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.gradientIntfunc}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc:nirfasterff-lib-nirfasterff-cpu-gradientintfunc}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc::doc}}\index{gradientIntfunc() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{gradientIntfunc()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc:nirfasterff.lib.nirfasterff_cpu.gradientIntfunc}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{gradientIntfunc}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.gradientIntfunc2}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc2:nirfasterff-lib-nirfasterff-cpu-gradientintfunc2}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc2::doc}}\index{gradientIntfunc2() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{gradientIntfunc2()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.gradientIntfunc2:nirfasterff.lib.nirfasterff_cpu.gradientIntfunc2}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{gradientIntfunc2}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}}
{{ $\rightarrow$ numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.isCUDA}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.isCUDA:nirfasterff-lib-nirfasterff-cpu-iscuda}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.isCUDA::doc}}\index{isCUDA() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{isCUDA()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.isCUDA:nirfasterff.lib.nirfasterff_cpu.isCUDA}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{isCUDA}}}
{}
{{ $\rightarrow$ bool}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.mesh\_support}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.mesh_support:nirfasterff-lib-nirfasterff-cpu-mesh-support}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.mesh_support::doc}}\index{mesh\_support() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{mesh\_support()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.mesh_support:nirfasterff.lib.nirfasterff_cpu.mesh_support}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{mesh\_support}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}}
{{ $\rightarrow$ numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.pointLocation}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.pointLocation:nirfasterff-lib-nirfasterff-cpu-pointlocation}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.pointLocation::doc}}\index{pointLocation() (in module nirfasterff.lib.nirfasterff\_cpu)@\spxentry{pointLocation()}\spxextra{in module nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.pointLocation:nirfasterff.lib.nirfasterff_cpu.pointLocation}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{pointLocation}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfoCPU}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff-lib-nirfasterff-cpu-convergenceinfocpu}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU::doc}}\index{ConvergenceInfoCPU (class in nirfasterff.lib.nirfasterff\_cpu)@\spxentry{ConvergenceInfoCPU}\spxextra{class in nirfasterff.lib.nirfasterff\_cpu}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cpu.}}\sphinxbfcode{\sphinxupquote{ConvergenceInfoCPU}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{pybind11\_object}}
\index{\_\_init\_\_() (nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{\sphinxparam{\DUrole{n}{self}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU}]{\sphinxcrossref{nirfasterff.lib.nirfasterff\_cpu.ConvergenceInfoCPU}}}}}}
{{ $\rightarrow$ None}}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU:nirfasterff.lib.nirfasterff_cpu.ConvergenceInfoCPU.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}(self)
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\subsubsection*{Attributes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isConverged}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isConvergedToAbsoluteTolerance}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iteration}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{residual}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.lib.nirfasterff\_cuda}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda:module-nirfasterff.lib.nirfasterff_cuda}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda:nirfasterff-lib-nirfasterff-cuda}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda::doc}}\index{module@\spxentry{module}!nirfasterff.lib.nirfasterff\_cuda@\spxentry{nirfasterff.lib.nirfasterff\_cuda}}\index{nirfasterff.lib.nirfasterff\_cuda@\spxentry{nirfasterff.lib.nirfasterff\_cuda}!module@\spxentry{module}}\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_mass_matrix:nirfasterff.lib.nirfasterff_cuda.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix}}}}}(arg0, arg1, arg2, arg3, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_source_fl:nirfasterff.lib.nirfasterff_cuda.gen_source_fl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_source\_fl}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_CW:nirfasterff.lib.nirfasterff_cuda.get_field_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_CW}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_FD:nirfasterff.lib.nirfasterff_cuda.get_field_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_FD}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR:nirfasterff.lib.nirfasterff_cuda.get_field_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL:nirfasterff.lib.nirfasterff_cuda.get_field_TRFL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFL}}}}}(arg0, arg1, arg2, arg3, arg4, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL_moments:nirfasterff.lib.nirfasterff_cuda.get_field_TRFL_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFL\_moments}}}}}(arg0, arg1, arg2, ...)
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR_moments:nirfasterff.lib.nirfasterff_cuda.get_field_TR_moments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR\_moments}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
Overloaded function.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.gen\_mass\_matrix}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_mass_matrix:nirfasterff-lib-nirfasterff-cuda-gen-mass-matrix}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_mass_matrix::doc}}\index{gen\_mass\_matrix() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{gen\_mass\_matrix()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_mass_matrix:nirfasterff.lib.nirfasterff_cuda.gen_mass_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{gen\_mass\_matrix}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg3}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg4}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg5}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg6}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg7}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}\sphinxparamcomma \sphinxparam{\DUrole{n}{GPU}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{\sphinxhyphen{}1}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }numpy.ndarray\DUrole{p}{{[}}numpy.complex128\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.gen\_source\_fl}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_source_fl:nirfasterff-lib-nirfasterff-cuda-gen-source-fl}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_source_fl::doc}}\index{gen\_source\_fl() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{gen\_source\_fl()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.gen_source_fl:nirfasterff.lib.nirfasterff_cuda.gen_source_fl}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{gen\_source\_fl}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
gen\_source\_fl(arg0: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.float64{[}m, n{]}{]}

\item {} 
\sphinxAtStartPar
gen\_source\_fl(arg0: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg1: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg2: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.get\_field\_CW}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_CW:nirfasterff-lib-nirfasterff-cuda-get-field-cw}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_CW::doc}}\index{get\_field\_CW() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{get\_field\_CW()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_CW:nirfasterff.lib.nirfasterff_cuda.get_field_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{get\_field\_CW}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_CW(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: scipy.sparse.csc\_matrix{[}numpy.float64{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_CW(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.get\_field\_FD}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_FD:nirfasterff-lib-nirfasterff-cuda-get-field-fd}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_FD::doc}}\index{get\_field\_FD() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{get\_field\_FD()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_FD:nirfasterff.lib.nirfasterff_cuda.get_field_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{get\_field\_FD}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_FD(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.complex128{[}m, 1{]}, flags.writeable{]}, arg3: scipy.sparse.csc\_matrix{[}numpy.complex128{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_FD(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.complex128{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.complex128{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.complex128{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.get\_field\_TR}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR:nirfasterff-lib-nirfasterff-cuda-get-field-tr}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR::doc}}\index{get\_field\_TR() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{get\_field\_TR()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR:nirfasterff.lib.nirfasterff_cuda.get_field_TR}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{get\_field\_TR}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_TR(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: scipy.sparse.csc\_matrix{[}numpy.float64{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_TR(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\end{enumerate}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.get\_field\_TRFL}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL:nirfasterff-lib-nirfasterff-cuda-get-field-trfl}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL::doc}}\index{get\_field\_TRFL() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{get\_field\_TRFL()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL:nirfasterff.lib.nirfasterff_cuda.get_field_TRFL}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{get\_field\_TRFL}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg3}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg4}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg5}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_iter}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{AbsoluteTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{RelativeTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{divergence}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{100000000.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{GPU}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{\sphinxhyphen{}1}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }list\DUrole{p}{{[}}{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU}]{\sphinxcrossref{nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.get\_field\_TRFL\_moments}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL_moments:nirfasterff-lib-nirfasterff-cuda-get-field-trfl-moments}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL_moments::doc}}\index{get\_field\_TRFL\_moments() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{get\_field\_TRFL\_moments()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TRFL_moments:nirfasterff.lib.nirfasterff_cuda.get_field_TRFL_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{get\_field\_TRFL\_moments}}}
{\sphinxparam{\DUrole{n}{arg0}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.int32\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg3}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg4}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg5}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{,}\DUrole{w}{ }flags.c\_contiguous\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg6}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg7}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }\DUrole{m}{1}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }flags.writeable\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arg8}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_iter}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{AbsoluteTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{RelativeTolerance}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{divergence}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{100000000.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{GPU}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{\sphinxhyphen{}1}}}
{{ $\rightarrow$ tuple\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{[}}numpy.float64\DUrole{p}{{[}}m\DUrole{p}{,}\DUrole{w}{ }n\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{ }list\DUrole{p}{{[}}{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU}]{\sphinxcrossref{nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.get\_field\_TR\_moments}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR_moments:nirfasterff-lib-nirfasterff-cuda-get-field-tr-moments}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR_moments::doc}}\index{get\_field\_TR\_moments() (in module nirfasterff.lib.nirfasterff\_cuda)@\spxentry{get\_field\_TR\_moments()}\spxextra{in module nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.get_field_TR_moments:nirfasterff.lib.nirfasterff_cuda.get_field_TR_moments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{get\_field\_TR\_moments}}}
{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Overloaded function.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
get\_field\_TR\_moments(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: scipy.sparse.csc\_matrix{[}numpy.float64{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\item {} 
\sphinxAtStartPar
get\_field\_TR\_moments(arg0: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg1: numpy.ndarray{[}numpy.int32{[}m, 1{]}, flags.writeable{]}, arg2: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg3: numpy.ndarray{[}numpy.float64{[}m, 1{]}, flags.writeable{]}, arg4: numpy.ndarray{[}numpy.float64{[}m, n{]}, flags.writeable, flags.c\_contiguous{]}, arg5: int, max\_iter: int = 1000, AbsoluteTolerance: float = 1e\sphinxhyphen{}12, RelativeTolerance: float = 1e\sphinxhyphen{}12, divergence: float = 100000000.0, GPU: int = \sphinxhyphen{}1) \sphinxhyphen{}\textgreater{} tuple{[}numpy.ndarray{[}numpy.float64{[}m, n{]}{]}, list{[}nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU{]}{]}

\end{enumerate}

\end{fulllineitems}

\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfoGPU}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU}
\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff-lib-nirfasterff-cuda-convergenceinfogpu}}\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU::doc}}\index{ConvergenceInfoGPU (class in nirfasterff.lib.nirfasterff\_cuda)@\spxentry{ConvergenceInfoGPU}\spxextra{class in nirfasterff.lib.nirfasterff\_cuda}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.lib.nirfasterff\_cuda.}}\sphinxbfcode{\sphinxupquote{ConvergenceInfoGPU}}}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{pybind11\_object}}
\index{\_\_init\_\_() (nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{\sphinxparam{\DUrole{n}{self}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU}]{\sphinxcrossref{nirfasterff.lib.nirfasterff\_cuda.ConvergenceInfoGPU}}}}}}
{{ $\rightarrow$ None}}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU:nirfasterff.lib.nirfasterff_cuda.ConvergenceInfoGPU.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}(self)
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\subsubsection*{Attributes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isConverged}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{isConvergedToAbsoluteTolerance}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iteration}}
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{residual}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.math}
\label{\detokenize{_autosummary/nirfasterff.math:module-nirfasterff.math}}\label{\detokenize{_autosummary/nirfasterff.math:nirfasterff-math}}\label{\detokenize{_autosummary/nirfasterff.math::doc}}\index{module@\spxentry{module}!nirfasterff.math@\spxentry{nirfasterff.math}}\index{nirfasterff.math@\spxentry{nirfasterff.math}!module@\spxentry{module}}
\sphinxAtStartPar
Some low\sphinxhyphen{}level functions used by the forward solvers.

\sphinxAtStartPar
It is usually unnecessary to use them directly and caution must be excercised, as many of them interact closely with the C++ libraries and can cause crashes if used incorrectly
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix}}}}}(mesh, omega{[}, solver, GPU{]})
&
\sphinxAtStartPar
Calculate the MASS matrix, and return the coordinates in CSR format.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources}}}}}(mesh)
&
\sphinxAtStartPar
Calculate the source vectors (point source only) for the sources in mesh.source field
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources_fl:nirfasterff.math.gen_sources_fl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources\_fl}}}}}(mesh, phix{[}, frequency, ...{]})
&
\sphinxAtStartPar
Calculates FEM sources vector for re\sphinxhyphen{}emission.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_boundary_data:nirfasterff.math.get_boundary_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_boundary\_data}}}}}(mesh, phi)
&
\sphinxAtStartPar
Calculates boundary data given the field data in mesh
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_CW:nirfasterff.math.get_field_CW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_CW}}}}}(csrI, csrJ, csrV, qvec{[}, opt, ...{]})
&
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_FD:nirfasterff.math.get_field_FD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_FD}}}}}(csrI, csrJ, csrV, qvec{[}, opt, ...{]})
&
\sphinxAtStartPar
Call the Preconditioned BiConjugate Stablized solver with FSAI preconditioner.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TR:nirfasterff.math.get_field_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR}}}}}(csrI, csrJ, csrV, qvec, dt, ...)
&
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRFL:nirfasterff.math.get_field_TRFL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFL}}}}}(csrI, csrJ, csrV, qvec\_m, dt, ...)
&
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRFLmoments:nirfasterff.math.get_field_TRFLmoments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRFLmoments}}}}}(csrI, csrJ, csrV, ...)
&
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRmoments:nirfasterff.math.get_field_TRmoments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRmoments}}}}}(csrI, csrJ, csrV, qvec, ...)
&
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.math.gen\_mass\_matrix}
\label{\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff-math-gen-mass-matrix}}\label{\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix::doc}}\index{gen\_mass\_matrix() (in module nirfasterff.math)@\spxentry{gen\_mass\_matrix()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{gen\_mass\_matrix}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{omega}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{GPU}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the MASS matrix, and return the coordinates in CSR format.

\sphinxAtStartPar
The current Matlab version outputs COO format, so the results are NOT directly compatible

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}) \textendash{} the mesh used to calculate the MASS matrix.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{omega}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} modulation frequency, in radian.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{GPU}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} GPU selection. \sphinxhyphen{}1 for automatic, 0, 1, … for manual selection on multi\sphinxhyphen{}GPU systems. The default is \sphinxhyphen{}1.

\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both CUDA and CPU versions fail.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if ‘solver’ is not ‘CPU’ or ‘GPU’.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{csrI} (\sphinxstyleemphasis{int32 NumPy vector, zero\sphinxhyphen{}based}) \textendash{} I indices of the MASS matrix, in CSR format. Size (NNodes,)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{csrJ} (\sphinxstyleemphasis{int32 NumPy vector, zero\sphinxhyphen{}based}) \textendash{} J indices of the MASS matrix, in CSR format. Size (nnz(MASS),)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{csrV} (\sphinxstyleemphasis{float64 or complex128 NumPy vector}) \textendash{} values of the MASS matrix, in CSR format. Size (nnz(MASS),)

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.gen\_sources}
\label{\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff-math-gen-sources}}\label{\detokenize{_autosummary/nirfasterff.math.gen_sources::doc}}\index{gen\_sources() (in module nirfasterff.math)@\spxentry{gen\_sources()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{gen\_sources}}}
{\sphinxparam{\DUrole{n}{mesh}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the source vectors (point source only) for the sources in mesh.source field
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{NIRFASTer mesh type}}) \textendash{} mesh used to calculate the source vectors. Source information is also defined here.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{qvec} \textendash{} source vectors, where each column corresponds to one source. Size (NNodes, Nsources).

\sphinxlineitem{Return type}
\sphinxAtStartPar
complex double NumPy array

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.gen\_sources\_fl}
\label{\detokenize{_autosummary/nirfasterff.math.gen_sources_fl:nirfasterff-math-gen-sources-fl}}\label{\detokenize{_autosummary/nirfasterff.math.gen_sources_fl::doc}}\index{gen\_sources\_fl() (in module nirfasterff.math)@\spxentry{gen\_sources\_fl()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.gen_sources_fl:nirfasterff.math.gen_sources_fl}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{gen\_sources\_fl}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{phix}}\sphinxparamcomma \sphinxparam{\DUrole{n}{frequency}\DUrole{o}{=}\DUrole{default_value}{0.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{GPU}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates FEM sources vector for re\sphinxhyphen{}emission.

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} mesh used to calcualte the source vectors. Source information is also defined here.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{phix}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} excitation fluence calculated at each node for each source. Size (NNodes, NSources)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{frequency}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} modulation frequency, in Hz. The default is 0..

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{GPU}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} GPU selection. \sphinxhyphen{}1 for automatic, 0, 1, … for manual selection on multi\sphinxhyphen{}GPU systems. The default is \sphinxhyphen{}1.

\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both CUDA and CPU versions fail.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if ‘solver’ is not ‘CPU’ or ‘GPU’.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{qvec} \textendash{} calculated fluence emission source vectors. Size (NNodes, NSources)

\sphinxlineitem{Return type}
\sphinxAtStartPar
double or complex double NumPy array

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.get\_boundary\_data}
\label{\detokenize{_autosummary/nirfasterff.math.get_boundary_data:nirfasterff-math-get-boundary-data}}\label{\detokenize{_autosummary/nirfasterff.math.get_boundary_data::doc}}\index{get\_boundary\_data() (in module nirfasterff.math)@\spxentry{get\_boundary\_data()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.get_boundary_data:nirfasterff.math.get_boundary_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{get\_boundary\_data}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{phi}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates boundary data given the field data in mesh

\sphinxAtStartPar
The field data can be any of the supported type: fluence, TPSF, or moments
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff mesh type}}) \textendash{} the mesh whose boundary and detectors are used for the calculation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{complex double NumPy array}}) \textendash{} field data as calculated by one of the ‘get\_field\_*’ solvers. Size (NNodes, NSources)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{data} \textendash{} measured boundary data at each channel. Size (NChannels,).

\sphinxlineitem{Return type}
\sphinxAtStartPar
double or complex double NumPy array

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.get\_field\_CW}
\label{\detokenize{_autosummary/nirfasterff.math.get_field_CW:nirfasterff-math-get-field-cw}}\label{\detokenize{_autosummary/nirfasterff.math.get_field_CW::doc}}\index{get\_field\_CW() (in module nirfasterff.math)@\spxentry{get\_field\_CW()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.get_field_CW:nirfasterff.math.get_field_CW}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{get\_field\_CW}}}
{\sphinxparam{\DUrole{n}{csrI}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrJ}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrV}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner. For CW data only.

\sphinxAtStartPar
The current Matlab version uses COO format input, so they are NOT directly compatible

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.

\sphinxAtStartPar
On GPU, the algorithm first tries to solve for all sources simultaneously, but this can fail due to insufficient GPU memory.

\sphinxAtStartPar
If this is the case, it will generate a warning and solve the sources one by one. The latter is not as fast, but requires much less memory.

\sphinxAtStartPar
On CPU, the algorithm only solves the sources one by one.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrI}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} I indices of the MASS matrix, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrJ}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} J indices of the MASS matrix, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrV}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}) \textendash{} values of the MASS matrix, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{qvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}\sphinxstyleliteralemphasis{\sphinxupquote{Scipy CSC sparse matrix}}) \textendash{} 
\sphinxAtStartPar
The source vectors. i\sphinxhyphen{}th column corresponds to source i. Size (NNode, NSource)

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if MASS matrix and source vectors are not both real, or if solver is not ‘CPU’ or ‘GPU’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both GPU and CPU solvers fail.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{phi} (\sphinxstyleemphasis{double NumPy array}) \textendash{} Calculated fluence at each source. Size (NNodes, Nsources)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.get\_field\_FD}
\label{\detokenize{_autosummary/nirfasterff.math.get_field_FD:nirfasterff-math-get-field-fd}}\label{\detokenize{_autosummary/nirfasterff.math.get_field_FD::doc}}\index{get\_field\_FD() (in module nirfasterff.math)@\spxentry{get\_field\_FD()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.get_field_FD:nirfasterff.math.get_field_FD}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{get\_field\_FD}}}
{\sphinxparam{\DUrole{n}{csrI}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrJ}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrV}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Call the Preconditioned BiConjugate Stablized solver with FSAI preconditioner.

\sphinxAtStartPar
This is designed for FD data, but can also work for CW is an all\sphinxhyphen{}zero imaginary part is added to the MASS matrix and source vectors.

\sphinxAtStartPar
The current Matlab version uses COO format input, so they are NOT directly compatible

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.

\sphinxAtStartPar
On GPU, the algorithm first tries to solve for all sources simultaneously, but this can fail due to insufficient GPU memory.

\sphinxAtStartPar
If this is the case, it will generate a warning and solve the sources one by one. The latter is not as fast, but requires much less memory.

\sphinxAtStartPar
On CPU, the algorithm only solves the sources one by one.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrI}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} I indices of the MASS matrix, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrJ}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} J indices of the MASS matrix, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrV}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex double NumPy vector}}) \textendash{} values of the MASS matrix, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{qvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}\sphinxstyleliteralemphasis{\sphinxupquote{Scipy CSC sparse matrix}}) \textendash{} 
\sphinxAtStartPar
The source vectors. i\sphinxhyphen{}th column corresponds to source i. Size (NNode, NSource)

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if MASS matrix and source vectors are not both complex, or if solver is not ‘CPU’ or ‘GPU’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both GPU and CPU solvers fail.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{phi} (\sphinxstyleemphasis{complex double NumPy array}) \textendash{} Calculated fluence at each source. Size (NNodes, Nsources)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.get\_field\_TR}
\label{\detokenize{_autosummary/nirfasterff.math.get_field_TR:nirfasterff-math-get-field-tr}}\label{\detokenize{_autosummary/nirfasterff.math.get_field_TR::doc}}\index{get\_field\_TR() (in module nirfasterff.math)@\spxentry{get\_field\_TR()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.get_field_TR:nirfasterff.math.get_field_TR}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{get\_field\_TR}}}
{\sphinxparam{\DUrole{n}{csrI}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrJ}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrV}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_step}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner. Calculates TPSF data

\sphinxAtStartPar
NOT interchangeable with the current MATLAB version

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.

\sphinxAtStartPar
On both GPU and CPU, the algorithm solves the sources one by one
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrI}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} I indices of the MASS matrices, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrJ}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} J indices of the MASS matrices, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrV}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex double NumPy vector}}) \textendash{} 
\sphinxAtStartPar
values of the MASS matrices, in CSR format.

\sphinxAtStartPar
This is calculated using gen\_mass\_matrix with omega=1. The real part coincides with K+C, and the imaginary part coincides with \sphinxhyphen{}M.

\sphinxAtStartPar
See references for details


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{qvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}\sphinxstyleliteralemphasis{\sphinxupquote{Scipy CSC sparse matrix}}) \textendash{} 
\sphinxAtStartPar
The source vectors. i\sphinxhyphen{}th column corresponds to source i. Size (NNode, NSource)

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_sources:nirfasterff.math.gen_sources}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_sources()}}}}} for details.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} time step size, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_step}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}) \textendash{} total number of time steps.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if csrV is not complex, or if qvec is not real, or if solver is not ‘CPU’ or ‘GPU’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both GPU and CPU solvers fail.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{phi} (\sphinxstyleemphasis{double NumPy array}) \textendash{} Calculated TPSF at each source. Size (NNodes, Nsources*max\_step), structured as,

\sphinxAtStartPar
{[}src0\_step0, src1\_step0,…,src0\_step1, src1\_step1,…{]}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}


\end{sphinxseealso}

\subsubsection*{References}

\sphinxAtStartPar
Arridge et al., Med. Phys,, 1993. doi:10.1118/1.597069

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.get\_field\_TRFL}
\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRFL:nirfasterff-math-get-field-trfl}}\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRFL::doc}}\index{get\_field\_TRFL() (in module nirfasterff.math)@\spxentry{get\_field\_TRFL()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRFL:nirfasterff.math.get_field_TRFL}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{get\_field\_TRFL}}}
{\sphinxparam{\DUrole{n}{csrI}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrJ}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrV}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qvec\_m}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dt}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_step}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner. Calculates the TPSFs of fluorescence emission given the TPSFs of excitation

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.

\sphinxAtStartPar
On both GPU and CPU, the algorithm solves the sources one by one
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrI}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} I indices of the MASS matrices at emission wavelength, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrJ}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} J indices of the MASS matrices at emission wavelength, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrV}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex double NumPy vector}}) \textendash{} 
\sphinxAtStartPar
values of the MASS matrices at emission wavelength, in CSR format.

\sphinxAtStartPar
This is calculated using gen\_mass\_matrix with omega=1.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{qvec\_m}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} 
\sphinxAtStartPar
TPSF of the excitation convolved with decay, and multiplied by the FEM matrix. Size (NNodes, NSources*NTime), structured as,

\sphinxAtStartPar
{[}src0\_step0, src1\_step0,…,src0\_step1, src1\_step1,…{]}


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} time step size, in seconds.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_step}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}) \textendash{} total number of time steps. It should match exactly with the number of steps in the excitation data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if csrV is not complex, or if phix is not real, or if solver is not ‘CPU’ or ‘GPU’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both GPU and CPU solvers fail.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{phi} (\sphinxstyleemphasis{double NumPy array}) \textendash{} Calculated TPSF at each source of fluorescence emission. Size (NNodes, Nsources*max\_step), structured as,

\sphinxAtStartPar
{[}src0\_step0, src1\_step0,…,src0\_step1, src1\_step1,…{]}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of the last time step is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TR:nirfasterff.math.get_field_TR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TR()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.get\_field\_TRFLmoments}
\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRFLmoments:nirfasterff-math-get-field-trflmoments}}\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRFLmoments::doc}}\index{get\_field\_TRFLmoments() (in module nirfasterff.math)@\spxentry{get\_field\_TRFLmoments()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRFLmoments:nirfasterff.math.get_field_TRFLmoments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{get\_field\_TRFLmoments}}}
{\sphinxparam{\DUrole{n}{csrI}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrJ}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrV}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrV2}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{gamma}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tau}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_moment}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner. Directly calculates moments of re\sphinxhyphen{}emission using Mellin transform, given the moments of excitation

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.

\sphinxAtStartPar
On both GPU and CPU, the algorithm solves the sources one by one
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrI}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} I indices of the MASS matrices at emission wavelength, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrJ}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} J indices of the MASS matrices at emission wavelength, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrV}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex double NumPy vector}}) \textendash{} 
\sphinxAtStartPar
values of the MASS matrices at emission wavelength, in CSR format.

\sphinxAtStartPar
This is calculated using gen\_mass\_matrix with omega=1.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrV2}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}) \textendash{} 
\sphinxAtStartPar
values of the FEM integration matrix, in CSR format.

\sphinxAtStartPar
This is calculated using gen\_mass\_matrix with omega=0, mua=1, kappa=0, and no boundary nodes.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mx}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} 
\sphinxAtStartPar
moments of the excitation. Size (NNodes, Nsources*(max\_moment+1)), structured as,

\sphinxAtStartPar
{[}src0\_m0, src1\_m0,…,src0\_m1, src1\_m1,…{]}


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} defined as mesh.eta*mesh.muaf.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} decay factor, as defined in mesh.tau.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_moment}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}) \textendash{} 
\sphinxAtStartPar
max order of moments to calculate. That is, 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th will be calculated.

\sphinxAtStartPar
This should match exact with the max\_moment of the excitation


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if csrV is not complex, or if mx is not real, or if solver is not ‘CPU’ or ‘GPU’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both GPU and CPU solvers fail.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{phi} (\sphinxstyleemphasis{double NumPy array}) \textendash{} Calculated Mellin transform of fluorecence emission at each source. Size (NNodes, Nsources*(max\_moment+1)), structured as,

\sphinxAtStartPar
{[}src0\_m0, src1\_m0,…,src0\_m1, src1\_m1,…{]}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of the highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}, {\hyperref[\detokenize{_autosummary/nirfasterff.math.get_field_TRmoments:nirfasterff.math.get_field_TRmoments}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_field\_TRmoments()}}}}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.math.get\_field\_TRmoments}
\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRmoments:nirfasterff-math-get-field-trmoments}}\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRmoments::doc}}\index{get\_field\_TRmoments() (in module nirfasterff.math)@\spxentry{get\_field\_TRmoments()}\spxextra{in module nirfasterff.math}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.math.get_field_TRmoments:nirfasterff.math.get_field_TRmoments}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.math.}}\sphinxbfcode{\sphinxupquote{get\_field\_TRmoments}}}
{\sphinxparam{\DUrole{n}{csrI}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrJ}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csrV}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qvec}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_moment}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.SolverOptions()}}\sphinxparamcomma \sphinxparam{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{utils.get\_solver()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner. Directly calculates moments of TR data using Mellin transform

\sphinxAtStartPar
NOT interchangeable with the current MATLAB version

\sphinxAtStartPar
If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.

\sphinxAtStartPar
On both GPU and CPU, the algorithm solves the sources one by one
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrI}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} I indices of the MASS matrices, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrJ}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{zero\sphinxhyphen{}based}}) \textendash{} J indices of the MASS matrices, in CSR format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csrV}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex double NumPy vector}}) \textendash{} 
\sphinxAtStartPar
values of the MASS matrices, in CSR format.

\sphinxAtStartPar
This is calculated using gen\_mass\_matrix with omega=1. The real part coincides with K+C, and the imaginary part coincides with \sphinxhyphen{}B.

\sphinxAtStartPar
See references for details


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{qvec}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}\sphinxstyleliteralemphasis{\sphinxupquote{Scipy CSC sparse matrix}}) \textendash{} The source vectors. i\sphinxhyphen{}th column corresponds to source i. Size (NNode, NSource)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_moment}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}) \textendash{} max order of moments to calculate. That is, 0th, 1st, 2nd, .., max\_moments\sphinxhyphen{}th will be calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Choose between ‘CPU’ or ‘GPU’ solver (case insensitive). Automatically determined (GPU prioritized) if not specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.SolverOptions}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Solver options. Uses default parameters if not specified, and they should suffice in most cases.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions()}}}}} for details


\end{itemize}

\sphinxlineitem{Raises}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if csrV is not complex, or if qvec is not real, or if solver is not ‘CPU’ or ‘GPU’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} if both GPU and CPU solvers fail.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{phi} (\sphinxstyleemphasis{double NumPy array}) \textendash{} Calculated Mellin transform at each source. Size (NNodes, Nsources*(max\_moment+1)), structured as,

\sphinxAtStartPar
{[}src0\_m0, src1\_m0,…,src0\_m1, src1\_m1,…{]}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info} (\sphinxstyleemphasis{nirfasterff.utils.ConvergenceInfo}) \textendash{} convergence information of the solver.

\sphinxAtStartPar
Only the convergence info of the highest order moments is returned.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo()}}}}} for details

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.math.gen_mass_matrix:nirfasterff.math.gen_mass_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_mass\_matrix()}}}}}


\end{sphinxseealso}

\subsubsection*{References}

\sphinxAtStartPar
Arridge and Schweiger, Applied Optics, 1995. doi:10.1364/AO.34.002683

\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.meshing}
\label{\detokenize{_autosummary/nirfasterff.meshing:module-nirfasterff.meshing}}\label{\detokenize{_autosummary/nirfasterff.meshing:nirfasterff-meshing}}\label{\detokenize{_autosummary/nirfasterff.meshing::doc}}\index{module@\spxentry{module}!nirfasterff.meshing@\spxentry{nirfasterff.meshing}}\index{nirfasterff.meshing@\spxentry{nirfasterff.meshing}!module@\spxentry{module}}
\sphinxAtStartPar
Functions used for mesh generation and quality check
\subsubsection*{Modules}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.auxiliary:module-nirfasterff.meshing.auxiliary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{auxiliary}}}}}
&
\sphinxAtStartPar
Auxiliary functions used for mesh quality check.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.meshutils:module-nirfasterff.meshing.meshutils}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{meshutils}}}}}
&
\sphinxAtStartPar
Functions used for mesh generation and mesh quality check
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.meshing.auxiliary}
\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary:module-nirfasterff.meshing.auxiliary}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary:nirfasterff-meshing-auxiliary}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary::doc}}\index{module@\spxentry{module}!nirfasterff.meshing.auxiliary@\spxentry{nirfasterff.meshing.auxiliary}}\index{nirfasterff.meshing.auxiliary@\spxentry{nirfasterff.meshing.auxiliary}!module@\spxentry{module}}
\sphinxAtStartPar
Auxiliary functions used for mesh quality check.

\sphinxAtStartPar
They are unlikely to become useful to an ordinary user, but still documented for completeness

\sphinxAtStartPar
Use with caution: no error checking mechanisms implemented
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_facearea:nirfasterff.meshing.auxiliary.check_facearea}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_facearea}}}}}(nodes, ele)
&
\sphinxAtStartPar
Calculates the areas of each face, and check if they are close to zero
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_tetrahedron_faces:nirfasterff.meshing.auxiliary.check_tetrahedron_faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_tetrahedron\_faces}}}}}(ele)
&
\sphinxAtStartPar
Check for faces shared by more than two tetrahedrons
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.auxiliary.checkedges:nirfasterff.meshing.auxiliary.checkedges}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{checkedges}}}}}(ele)
&
\sphinxAtStartPar
Check for orphan edges and edges shared by more than two triangles
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.auxiliary.quality_triangle_radius:nirfasterff.meshing.auxiliary.quality_triangle_radius}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{quality\_triangle\_radius}}}}}(nodes, ele)
&
\sphinxAtStartPar
Radius ratio: 2*inradius / circumradius
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.auxiliary.simpqual:nirfasterff.meshing.auxiliary.simpqual}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{simpqual}}}}}(nodes, ele)
&
\sphinxAtStartPar
For each tetrahedron, calculates the didehedral angles and returns the smallest sine of them
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.auxiliary.vector_vector_angle:nirfasterff.meshing.auxiliary.vector_vector_angle}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vector\_vector\_angle}}}}}(u, v)
&
\sphinxAtStartPar
Calculates vector\sphinxhyphen{}vector angles, in radian
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.meshing.auxiliary.check\_facearea}
\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_facearea:nirfasterff-meshing-auxiliary-check-facearea}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_facearea::doc}}\index{check\_facearea() (in module nirfasterff.meshing.auxiliary)@\spxentry{check\_facearea()}\spxextra{in module nirfasterff.meshing.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_facearea:nirfasterff.meshing.auxiliary.check_facearea}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.auxiliary.}}\sphinxbfcode{\sphinxupquote{check\_facearea}}}
{\sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ele}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the areas of each face, and check if they are close to zero

\sphinxAtStartPar
Close to zero defined as 1e6 of the max span of the mesh
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{area} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} areas of each face. Size (NElements,)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{zeroflag} (\sphinxstyleemphasis{bool NumPy vector}) \textendash{} flags of whether the area is close to zero, for each face. Size (NElements,)

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.auxiliary.check\_tetrahedron\_faces}
\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_tetrahedron_faces:nirfasterff-meshing-auxiliary-check-tetrahedron-faces}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_tetrahedron_faces::doc}}\index{check\_tetrahedron\_faces() (in module nirfasterff.meshing.auxiliary)@\spxentry{check\_tetrahedron\_faces()}\spxextra{in module nirfasterff.meshing.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.check_tetrahedron_faces:nirfasterff.meshing.auxiliary.check_tetrahedron_faces}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.auxiliary.}}\sphinxbfcode{\sphinxupquote{check\_tetrahedron\_faces}}}
{\sphinxparam{\DUrole{n}{ele}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Check for faces shared by more than two tetrahedrons
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{flag} \textendash{} 0 if no faulty faces found, and 2 if faces shared by more than two tetrahedrons are found.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.auxiliary.checkedges}
\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.checkedges:nirfasterff-meshing-auxiliary-checkedges}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.checkedges::doc}}\index{checkedges() (in module nirfasterff.meshing.auxiliary)@\spxentry{checkedges()}\spxextra{in module nirfasterff.meshing.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.checkedges:nirfasterff.meshing.auxiliary.checkedges}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.auxiliary.}}\sphinxbfcode{\sphinxupquote{checkedges}}}
{\sphinxparam{\DUrole{n}{ele}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Check for orphan edges and edges shared by more than two triangles
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{flag} \textendash{} 0 if no errors found; 1 if edges shared by more than two triangles found; 2 if dangling edges found; 3 if both errors found.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.auxiliary.quality\_triangle\_radius}
\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.quality_triangle_radius:nirfasterff-meshing-auxiliary-quality-triangle-radius}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.quality_triangle_radius::doc}}\index{quality\_triangle\_radius() (in module nirfasterff.meshing.auxiliary)@\spxentry{quality\_triangle\_radius()}\spxextra{in module nirfasterff.meshing.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.quality_triangle_radius:nirfasterff.meshing.auxiliary.quality_triangle_radius}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.auxiliary.}}\sphinxbfcode{\sphinxupquote{quality\_triangle\_radius}}}
{\sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ele}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Radius ratio: 2*inradius / circumradius

\sphinxAtStartPar
Value between 0 and 1. Equals 1 only when a triangle is equilateral
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
radius ratios for each triangle. Size (NElements,)

\sphinxlineitem{Return type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
\sphinxurl{https://en.wikibooks.org/wiki/Trigonometry/Circles\_and\_Triangles/The\_Incircle}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.auxiliary.simpqual}
\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.simpqual:nirfasterff-meshing-auxiliary-simpqual}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.simpqual::doc}}\index{simpqual() (in module nirfasterff.meshing.auxiliary)@\spxentry{simpqual()}\spxextra{in module nirfasterff.meshing.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.simpqual:nirfasterff.meshing.auxiliary.simpqual}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.auxiliary.}}\sphinxbfcode{\sphinxupquote{simpqual}}}
{\sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ele}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
For each tetrahedron, calculates the didehedral angles and returns the smallest sine of them
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
smallest sine of the dihedral angles for each element. Size (NElements,)

\sphinxlineitem{Return type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
\sphinxurl{https://en.wikipedia.org/wiki/Dihedral\_angle}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.auxiliary.vector\_vector\_angle}
\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.vector_vector_angle:nirfasterff-meshing-auxiliary-vector-vector-angle}}\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.vector_vector_angle::doc}}\index{vector\_vector\_angle() (in module nirfasterff.meshing.auxiliary)@\spxentry{vector\_vector\_angle()}\spxextra{in module nirfasterff.meshing.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.auxiliary.vector_vector_angle:nirfasterff.meshing.auxiliary.vector_vector_angle}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.auxiliary.}}\sphinxbfcode{\sphinxupquote{vector\_vector\_angle}}}
{\sphinxparam{\DUrole{n}{u}}\sphinxparamcomma \sphinxparam{\DUrole{n}{v}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates vector\sphinxhyphen{}vector angles, in radian

\sphinxAtStartPar
Each row of u, v is a vector, and the angles are calculated pairwise row by row
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{u}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} first set of vectors.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} second set of vectors.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
pairwise vector\sphinxhyphen{}vector angles, in radian. Same number of rows as u and v

\sphinxlineitem{Return type}
\sphinxAtStartPar
double NumPy vector

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.meshing.meshutils}
\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils:module-nirfasterff.meshing.meshutils}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils:nirfasterff-meshing-meshutils}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils::doc}}\index{module@\spxentry{module}!nirfasterff.meshing.meshutils@\spxentry{nirfasterff.meshing.meshutils}}\index{nirfasterff.meshing.meshutils@\spxentry{nirfasterff.meshing.meshutils}!module@\spxentry{module}}
\sphinxAtStartPar
Functions used for mesh generation and mesh quality check
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh2D:nirfasterff.meshing.meshutils.CheckMesh2D}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CheckMesh2D}}}}}(elements, nodes{[}, base, verbose{]})
&
\sphinxAtStartPar
Main function that calculates and checks the quality of a 2D mesh
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh3D:nirfasterff.meshing.meshutils.CheckMesh3D}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CheckMesh3D}}}}}(elements, nodes{[}, base, verbose{]})
&
\sphinxAtStartPar
Main function that calculates and checks the quality of a 3D mesh, which can be either a solid or surface mesh
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.meshutils.RunCGALMeshGenerator:nirfasterff.meshing.meshutils.RunCGALMeshGenerator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RunCGALMeshGenerator}}}}}(mask{[}, opt{]})
&
\sphinxAtStartPar
Generate a tetrahedral mesh from a volume using CGAL 6.0.1 mesher, where different regions are labeled used a distinct integer.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.meshutils.boundfaces:nirfasterff.meshing.meshutils.boundfaces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{boundfaces}}}}}(nodes, elements{[}, base, renumber{]})
&
\sphinxAtStartPar
Finds the boundary faces of a 3D tetrahedral mesh
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_solid:nirfasterff.meshing.meshutils.checkmesh3d_solid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{checkmesh3d\_solid}}}}}(ele, nodes{[}, verbose{]})
&
\sphinxAtStartPar
Calculates and returns the quality metrics of the tetrahedrons in a 3D tetrahedral mesh
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_surface:nirfasterff.meshing.meshutils.checkmesh3d_surface}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{checkmesh3d\_surface}}}}}(ele, nodes{[}, verbose{]})
&
\sphinxAtStartPar
Calculates and returns the quality metrics of the triangles in a 3D surface mesh
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\paragraph{nirfasterff.meshing.meshutils.CheckMesh2D}
\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh2D:nirfasterff-meshing-meshutils-checkmesh2d}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh2D::doc}}\index{CheckMesh2D() (in module nirfasterff.meshing.meshutils)@\spxentry{CheckMesh2D()}\spxextra{in module nirfasterff.meshing.meshutils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh2D:nirfasterff.meshing.meshutils.CheckMesh2D}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.meshutils.}}\sphinxbfcode{\sphinxupquote{CheckMesh2D}}}
{\sphinxparam{\DUrole{n}{elements}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Main function that calculates and checks the quality of a 2D mesh
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elements}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh, in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} one\sphinxhyphen{} or zero\sphinxhyphen{}based indexing of the element list. Can be 1, or 0. The default is 1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether print the problematic elements to stdout, if any. The default is False.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if elements and nodes do not define a valid 2D mesh.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{flag} (\sphinxstyleemphasis{int}) \textendash{} flags of mesh quality, set by bits: ‘b2b1b0’.

\sphinxAtStartPar
b1 set if faulty edges found; b2 set if triangles with small area found

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{q\_radius\_ratio} (\sphinxstyleemphasis{double NumPy array}) \textendash{} radius ratio of each triangle, defined as \sphinxtitleref{2*inradius / circumradius}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{area} (\sphinxstyleemphasis{double NumPy array}) \textendash{} area of each triangle in mesh.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.meshutils.CheckMesh3D}
\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh3D:nirfasterff-meshing-meshutils-checkmesh3d}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh3D::doc}}\index{CheckMesh3D() (in module nirfasterff.meshing.meshutils)@\spxentry{CheckMesh3D()}\spxextra{in module nirfasterff.meshing.meshutils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.CheckMesh3D:nirfasterff.meshing.meshutils.CheckMesh3D}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.meshutils.}}\sphinxbfcode{\sphinxupquote{CheckMesh3D}}}
{\sphinxparam{\DUrole{n}{elements}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Main function that calculates and checks the quality of a 3D mesh, which can be either a solid or surface mesh

\sphinxAtStartPar
If surface mesh, checkmesh3d\_surface() is called

\sphinxAtStartPar
If solid mesh, checkmesh3d\_solid() is first used, and checkmesh3d\_surface() is subsequently used to check its outer surface
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh, in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} one\sphinxhyphen{} or zero\sphinxhyphen{}based indexing of the element list. Can be 1, or 0. The default is 1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether print the problematic elements to stdout, if any. The default is False.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if elements and nodes do not define a valid 3D mesh.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{vol} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} Volume (for solid mesh) or area (for surface mesh) of each element.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{vol\_ratio} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} volume ratio for each tetrahedron in a solid mesh. Returns scalar 0.0 in case of a surface mesh.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{q\_area} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} area ratio for each triangle in a surface mesh. Returns scalar 0.0 in case of a solid mesh.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{status\_solid} (\sphinxstyleemphasis{int}) \textendash{} flags of solid mesh quality, set by bits: ‘b3b2b1b0’.

\sphinxAtStartPar
b1 set if small volumes found; b2 set if small volume ratios found; b3 set if faces shared by more than two tetrahedrons found

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{status\_surface} (\sphinxstyleemphasis{int}) \textendash{} flags of surface mesh quality, set by bits: ‘b3b2b1b0’.

\sphinxAtStartPar
b1 set if edges shared by more than two triangles found; b2 set if dangling edges found; b3 triangles with small area found

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nirfasterff.meshing.checkmesh3d\_solid()}}, \sphinxcode{\sphinxupquote{nirfasterff.meshing.checkmesh3d\_surface()}}


\end{sphinxseealso}


\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.meshutils.RunCGALMeshGenerator}
\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.RunCGALMeshGenerator:nirfasterff-meshing-meshutils-runcgalmeshgenerator}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.RunCGALMeshGenerator::doc}}\index{RunCGALMeshGenerator() (in module nirfasterff.meshing.meshutils)@\spxentry{RunCGALMeshGenerator()}\spxextra{in module nirfasterff.meshing.meshutils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.RunCGALMeshGenerator:nirfasterff.meshing.meshutils.RunCGALMeshGenerator}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.meshutils.}}\sphinxbfcode{\sphinxupquote{RunCGALMeshGenerator}}}
{\sphinxparam{\DUrole{n}{mask}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{utils.MeshingParams()}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Generate a tetrahedral mesh from a volume using CGAL 6.0.1 mesher, where different regions are labeled used a distinct integer.

\sphinxAtStartPar
Internallly, the function makes a system call to the mesher binary, which can also be used standalone through the command line.

\sphinxAtStartPar
Also runs a pruning steps after the mesh generation, where nodes not referred to in the element list are removed.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{uint8 NumPy array}}) \textendash{} 3D volumetric data defining the space to mesh. Regions defined by different integers. 0 is background.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt}} ({\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.utils.MeshingParams}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
meshing parameters used. Default values will be used if not specified.

\sphinxAtStartPar
See {\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nirfasterff.utils.MeshingParams()}}}}} for details


\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ele} (\sphinxstyleemphasis{int NumPy array}) \textendash{} element list calculated by the mesher, one\sphinxhyphen{}based. Last column indicates the region each element belongs to

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{nodes} (\sphinxstyleemphasis{double NumPy array}) \textendash{} element list calculated by the mesher, in mm.

\end{itemize}


\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
\sphinxurl{https://doc.cgal.org/latest/Mesh\_3/index.html\#Chapter\_3D\_Mesh\_Generation}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.meshutils.boundfaces}
\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.boundfaces:nirfasterff-meshing-meshutils-boundfaces}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.boundfaces::doc}}\index{boundfaces() (in module nirfasterff.meshing.meshutils)@\spxentry{boundfaces()}\spxextra{in module nirfasterff.meshing.meshutils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.boundfaces:nirfasterff.meshing.meshutils.boundfaces}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.meshutils.}}\sphinxbfcode{\sphinxupquote{boundfaces}}}
{\sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elements}}\sphinxparamcomma \sphinxparam{\DUrole{n}{base}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{renumber}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Finds the boundary faces of a 3D tetrahedral mesh
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh. Size (NNodes, 3)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elements}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} element list of the mesh, can be either one\sphinxhyphen{}based or zero\sphinxhyphen{}based, which must be specified using the ‘base’ argument.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} one\sphinxhyphen{} or zero\sphinxhyphen{}based indexing of the element list. Can be 1, or 0. The default is 0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{renumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether renumber of the node indices in the extracted surface mesh. The default is True.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{new\_faces} (\sphinxstyleemphasis{int32 NumPy array}) \textendash{} list of boundary faces of the mesh. Base of indexing is consistent with input element list

\sphinxAtStartPar
If \sphinxtitleref{renumber=True}, node indices are renumbered; if not, same node indices as in ‘elements’ are used

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{new\_points} (\sphinxstyleemphasis{double NumPy array}) \textendash{} point locations of the boundary nodes.

\sphinxAtStartPar
If \sphinxtitleref{renumber=True}, returns the subset of node loations that are on the surface; if not, it is the same as input \sphinxtitleref{nodes}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.meshutils.checkmesh3d\_solid}
\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_solid:nirfasterff-meshing-meshutils-checkmesh3d-solid}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_solid::doc}}\index{checkmesh3d\_solid() (in module nirfasterff.meshing.meshutils)@\spxentry{checkmesh3d\_solid()}\spxextra{in module nirfasterff.meshing.meshutils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_solid:nirfasterff.meshing.meshutils.checkmesh3d_solid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.meshutils.}}\sphinxbfcode{\sphinxupquote{checkmesh3d\_solid}}}
{\sphinxparam{\DUrole{n}{ele}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates and returns the quality metrics of the tetrahedrons in a 3D tetrahedral mesh

\sphinxAtStartPar
Please consider using \sphinxcode{\sphinxupquote{nirfasterff.meshing.CheckMesh3D()}} instead.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh, in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether print the problematic tetrahedrons to stdout, if any. The default is False.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not 3D tetrahedral, or if element list uses undefined nodes.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{vol} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} volume of each tetrahedron, mm\textasciicircum{}3.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{vol\_ratio} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} volume ratio, defined as the smallest sine of dihedral angles of each tetrahedron.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{zeroflag} (\sphinxstyleemphasis{bool NumPy vector}) \textendash{} flags of whether the volume of a tetrahedron is too small.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{faceflag} (\sphinxstyleemphasis{bool}) \textendash{} whether there are faces shared by more than two tetrahedrons.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\paragraph{nirfasterff.meshing.meshutils.checkmesh3d\_surface}
\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_surface:nirfasterff-meshing-meshutils-checkmesh3d-surface}}\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_surface::doc}}\index{checkmesh3d\_surface() (in module nirfasterff.meshing.meshutils)@\spxentry{checkmesh3d\_surface()}\spxextra{in module nirfasterff.meshing.meshutils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.meshing.meshutils.checkmesh3d_surface:nirfasterff.meshing.meshutils.checkmesh3d_surface}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.meshing.meshutils.}}\sphinxbfcode{\sphinxupquote{checkmesh3d\_surface}}}
{\sphinxparam{\DUrole{n}{ele}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates and returns the quality metrics of the triangles in a 3D surface mesh

\sphinxAtStartPar
Please consider using \sphinxcode{\sphinxupquote{nirfasterff.meshing.CheckMesh3D()}} instead.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32 NumPy array}}) \textendash{} element list of the mesh, zero\sphinxhyphen{}based.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy array}}) \textendash{} node locations of the mesh, in mm.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} whether print the problematic triangles to stdout, if any. The default is False.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh is not 3D tetrahedral, or if element list uses undefined nodes.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{q\_radius\_ratio} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} radius ratio of each triangle, defined as \sphinxtitleref{2*inradius / circumradius}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{q\_area\_ratio} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} face area divided by ‘ideal area’ for each triangle,

\sphinxAtStartPar
where ideal area is the area of an equilateral triangle whose edge length equals the longest edge in the face.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{area} (\sphinxstyleemphasis{double NumPy vector}) \textendash{} area of each triangle, in mm\textasciicircum{}2.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{zeroflag} (\sphinxstyleemphasis{bool NumPy vector}) \textendash{} flags whether the area a triangle is close to zero.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{edgeflag} (\sphinxstyleemphasis{int}) \textendash{} flag if any problematic edges. Flag set by bits ‘b1b0’:

\sphinxAtStartPar
b1=1 if dangling edges found, b0=1 if there exist edges shared by more than two triangles

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.utils}
\label{\detokenize{_autosummary/nirfasterff.utils:module-nirfasterff.utils}}\label{\detokenize{_autosummary/nirfasterff.utils:nirfasterff-utils}}\label{\detokenize{_autosummary/nirfasterff.utils::doc}}\index{module@\spxentry{module}!nirfasterff.utils@\spxentry{nirfasterff.utils}}\index{nirfasterff.utils@\spxentry{nirfasterff.utils}!module@\spxentry{module}}
\sphinxAtStartPar
Utility functions and auxiliary classes frequently used in the package.
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation:nirfasterff.utils.boundary_attenuation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{boundary\_attenuation}}}}}(n\_incidence{[}, ...{]})
&
\sphinxAtStartPar
Calculate the boundary attenuation factor between two media.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.check_element_orientation_2d:nirfasterff.utils.check_element_orientation_2d}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_element\_orientation\_2d}}}}}(ele, nodes)
&
\sphinxAtStartPar
Make sure the 2D triangular elements are oriented counter clock wise.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.compress_coo:nirfasterff.utils.compress_coo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{compress\_coo}}}}}(coo\_idx, N)
&
\sphinxAtStartPar
Convert COO indices to compressed.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.gen_intmat_impl:nirfasterff.utils.gen_intmat_impl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gen\_intmat\_impl}}}}}(mesh, xgrid, ygrid, zgrid)
&
\sphinxAtStartPar
YOU SHOULD NOT USE THIS FUNCTION DIRECTLY.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.get_nthread:nirfasterff.utils.get_nthread}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_nthread}}}}}()
&
\sphinxAtStartPar
Choose the number of OpenMP threads in CPU solvers
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.get_solver:nirfasterff.utils.get_solver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_solver}}}}}()
&
\sphinxAtStartPar
Get the default solver.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.isCUDA:nirfasterff.utils.isCUDA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isCUDA}}}}}()
&
\sphinxAtStartPar
Checks if system has a CUDA device with compute capability \textgreater{}=5.2
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.pointLineDistance:nirfasterff.utils.pointLineDistance}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pointLineDistance}}}}}(A, B, p)
&
\sphinxAtStartPar
Calculate the distance between a point and a line (defined by two points), and find the projection point
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.pointLocation:nirfasterff.utils.pointLocation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pointLocation}}}}}(mesh, pointlist)
&
\sphinxAtStartPar
Similar to Matlab\textquotesingle{}s pointLocation function, queries which elements in mesh the points belong to, and also calculate the barycentric coordinates.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.pointTriangleDistance:nirfasterff.utils.pointTriangleDistance}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pointTriangleDistance}}}}}(TRI, P)
&
\sphinxAtStartPar
Calculate the distance between a point and a triangle (defined by three points), and find the projection point
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.uncompress_coo:nirfasterff.utils.uncompress_coo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{uncompress\_coo}}}}}(compressed\_idx)
&
\sphinxAtStartPar
Convert compressed indices to COO.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.utils.boundary\_attenuation}
\label{\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation:nirfasterff-utils-boundary-attenuation}}\label{\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation::doc}}\index{boundary\_attenuation() (in module nirfasterff.utils)@\spxentry{boundary\_attenuation()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.boundary_attenuation:nirfasterff.utils.boundary_attenuation}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{boundary\_attenuation}}}
{\sphinxparam{\DUrole{n}{n\_incidence}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_transmission}\DUrole{o}{=}\DUrole{default_value}{1.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}robin\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the boundary attenuation factor between two media.

\sphinxAtStartPar
If vectors are used as inputs, they must have the same size and calculation is done for each pair

\sphinxAtStartPar
If n\_incidence is a vector but n\_transmission is a scalar, code assumes n\_transmission to be the same for each value in n\_incidence
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_incidence}} (\sphinxstyleliteralemphasis{\sphinxupquote{double Numpy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}) \textendash{} refractive index of the medium within the boundary, e.g. a tissue.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_transmission}} (\sphinxstyleliteralemphasis{\sphinxupquote{double Numpy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scalar}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} refractive index of the medium outside of the boundary, e.g. air. The default is 1.0.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
boundary type, which can be,

\sphinxAtStartPar
’robin’  \sphinxhyphen{} internal reflectance derived from Fresnel’s law

\sphinxAtStartPar
’approx’ \sphinxhyphen{} Groenhuis internal reflectance approximation \((1.440n^{-2} + 0.710n^{-1} + 0.668 + 0.00636n)\)

\sphinxAtStartPar
’exact’  \sphinxhyphen{} exact internal reflectance (integrals of polarised reflectances, etc.)

\sphinxAtStartPar
The default is ‘robin’.


\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if n\_incidence and n\_transmission are both vectors and have difference sizes, or if method is not of a recognized kind

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{A} \textendash{} calculated boundary attenuation factor.

\sphinxlineitem{Return type}
\sphinxAtStartPar
double Numpy vector or scalar

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Durduran et al, 2010, Rep. Prog. Phys. doi:10.1088/0034\sphinxhyphen{}4885/73/7/076701

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.check\_element\_orientation\_2d}
\label{\detokenize{_autosummary/nirfasterff.utils.check_element_orientation_2d:nirfasterff-utils-check-element-orientation-2d}}\label{\detokenize{_autosummary/nirfasterff.utils.check_element_orientation_2d::doc}}\index{check\_element\_orientation\_2d() (in module nirfasterff.utils)@\spxentry{check\_element\_orientation\_2d()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.check_element_orientation_2d:nirfasterff.utils.check_element_orientation_2d}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{check\_element\_orientation\_2d}}}
{\sphinxparam{\DUrole{n}{ele}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nodes}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Make sure the 2D triangular elements are oriented counter clock wise.

\sphinxAtStartPar
This is a direct translation from the Matlab version.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ele}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} Elements in a 2D mesh. One\sphinxhyphen{}based. Size: (NNodes, 3).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} Node locations in a 2D mesh. Size: (NNodes, 2).

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If ele does not have three rows, i.e. not a 2D triangular mesh.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{ele} \textendash{} Re\sphinxhyphen{}oriented element list.

\sphinxlineitem{Return type}
\sphinxAtStartPar
NumPy array

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.compress\_coo}
\label{\detokenize{_autosummary/nirfasterff.utils.compress_coo:nirfasterff-utils-compress-coo}}\label{\detokenize{_autosummary/nirfasterff.utils.compress_coo::doc}}\index{compress\_coo() (in module nirfasterff.utils)@\spxentry{compress\_coo()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.compress_coo:nirfasterff.utils.compress_coo}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{compress\_coo}}}
{\sphinxparam{\DUrole{n}{coo\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{N}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert COO indices to compressed.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coo\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int NumPy array}}) \textendash{} Input indices in COO format, zero\sphinxhyphen{}based.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{N}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of rows in the sparse matrix.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Output indices in compressed format, zero\sphinxhyphen{}based. Size (N+1,)

\sphinxlineitem{Return type}
\sphinxAtStartPar
int NumPy array

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.gen\_intmat\_impl}
\label{\detokenize{_autosummary/nirfasterff.utils.gen_intmat_impl:nirfasterff-utils-gen-intmat-impl}}\label{\detokenize{_autosummary/nirfasterff.utils.gen_intmat_impl::doc}}\index{gen\_intmat\_impl() (in module nirfasterff.utils)@\spxentry{gen\_intmat\_impl()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.gen_intmat_impl:nirfasterff.utils.gen_intmat_impl}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{gen\_intmat\_impl}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{xgrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ygrid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{zgrid}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
YOU SHOULD NOT USE THIS FUNCTION DIRECTLY. USE MESH.GEN\_INTMAT INSTEAD.

\sphinxAtStartPar
Heart of the gen\_intmat function, which calculates the necessary information for converting between mesh and grid space
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.stndmesh}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff.base.fluormesh}}) \textendash{} The original mesh with with FEM data is calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{float64 NumPy 1\sphinxhyphen{}D array}}) \textendash{} x grid in mm. Must be regular.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ygrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{float64 NumPy 1\sphinxhyphen{}D array}}) \textendash{} y grid in mm. Must be regular.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{zgrid}} (\sphinxstyleliteralemphasis{\sphinxupquote{float64 NumPy 1\sphinxhyphen{}D array}}\sphinxstyleliteralemphasis{\sphinxupquote{, or }}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{if 2D mesh}}) \textendash{} z grid in mm. Must be regular.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{gridinmesh} (\sphinxstyleemphasis{int32 NumPy array}) \textendash{} Col 0: indices of grid points that are in the mesh; Col 1: indeces of the elements the grid point is in. Flattened in ‘F’ order, one\sphinxhyphen{}based.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{meshingrid} (\sphinxstyleemphasis{int32 NumPy array}) \textendash{} Indices of mesh nodes that are in the grid. One\sphinxhyphen{}based.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{int\_mat\_mesh2grid} (\sphinxstyleemphasis{CSC sparse matrix, float64}) \textendash{} Sparse matrix converting data from mesh space to grid space. Size (NGrid, NNodes).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{int\_mat\_mesh2grid} (\sphinxstyleemphasis{CSC sparse matrix, float64}) \textendash{} Sparse matrix converting data from grid space to mesh space. Size (NNodes, NGrid).

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.get\_nthread}
\label{\detokenize{_autosummary/nirfasterff.utils.get_nthread:nirfasterff-utils-get-nthread}}\label{\detokenize{_autosummary/nirfasterff.utils.get_nthread::doc}}\index{get\_nthread() (in module nirfasterff.utils)@\spxentry{get\_nthread()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.get_nthread:nirfasterff.utils.get_nthread}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{get\_nthread}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Choose the number of OpenMP threads in CPU solvers

\sphinxAtStartPar
On CPUs with no hyperthreading, all physical cores are used
Otherwise use min(physical\_core, 8), i.e. no more than 8

\sphinxAtStartPar
This is heuristically determined to avoid performance loss due to memory bottlenecking

\sphinxAtStartPar
Advanced user can directly modify this function to choose the appropriate number of threads
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{nthread} \textendash{} number of OpenMP threads to use in CPU solvers.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.get\_solver}
\label{\detokenize{_autosummary/nirfasterff.utils.get_solver:nirfasterff-utils-get-solver}}\label{\detokenize{_autosummary/nirfasterff.utils.get_solver::doc}}\index{get\_solver() (in module nirfasterff.utils)@\spxentry{get\_solver()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.get_solver:nirfasterff.utils.get_solver}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{get\_solver}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get the default solver.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
If isCUDA is true, returns ‘GPU’, otherwise ‘CPU’.

\sphinxlineitem{Return type}
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.isCUDA}
\label{\detokenize{_autosummary/nirfasterff.utils.isCUDA:nirfasterff-utils-iscuda}}\label{\detokenize{_autosummary/nirfasterff.utils.isCUDA::doc}}\index{isCUDA() (in module nirfasterff.utils)@\spxentry{isCUDA()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.isCUDA:nirfasterff.utils.isCUDA}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{isCUDA}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Checks if system has a CUDA device with compute capability \textgreater{}=5.2

\sphinxAtStartPar
On a Mac machine, it automatically returns False without checking
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if a CUDA device with compute capability \textgreater{}=5.2 exists, False if not.

\sphinxlineitem{Return type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.pointLineDistance}
\label{\detokenize{_autosummary/nirfasterff.utils.pointLineDistance:nirfasterff-utils-pointlinedistance}}\label{\detokenize{_autosummary/nirfasterff.utils.pointLineDistance::doc}}\index{pointLineDistance() (in module nirfasterff.utils)@\spxentry{pointLineDistance()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.pointLineDistance:nirfasterff.utils.pointLineDistance}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{pointLineDistance}}}
{\sphinxparam{\DUrole{n}{A}}\sphinxparamcomma \sphinxparam{\DUrole{n}{B}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the distance between a point and a line (defined by two points), and find the projection point

\sphinxAtStartPar
This is a direct translation  from the Matlab version
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} first point on the line. Size (2,) or (3,)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{B}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} second point on the line. Size (2,) or (3,)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} point of query. Size (2,) or (3,)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dist} (\sphinxstyleemphasis{double}) \textendash{} point\sphinxhyphen{}line distance.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{point} (\sphinxstyleemphasis{NumPy array}) \textendash{} projection point on the line.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.pointLocation}
\label{\detokenize{_autosummary/nirfasterff.utils.pointLocation:nirfasterff-utils-pointlocation}}\label{\detokenize{_autosummary/nirfasterff.utils.pointLocation::doc}}\index{pointLocation() (in module nirfasterff.utils)@\spxentry{pointLocation()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.pointLocation:nirfasterff.utils.pointLocation}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{pointLocation}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{pointlist}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Similar to Matlab’s pointLocation function, queries which elements in mesh the points belong to, and also calculate the barycentric coordinates.

\sphinxAtStartPar
This is a wrapper of the C++ function pointLocation, which implememnts an AABB tree based on Darren Engwirda’s findtria package
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{NIRFASTer mesh}}) \textendash{} Can be any of the NIRFASTer mesh types (stnd, fluor, dcs). 2D or 3D.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pointlist}} (\sphinxstyleliteralemphasis{\sphinxupquote{NumPy array}}) \textendash{} A list of points to query. Shape (N, dim), where N is number of points.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ind} (\sphinxstyleemphasis{double NumPy array}) \textendash{} i\sphinxhyphen{}th queried point is in element \sphinxtitleref{ind{[}i}{]} of mesh (zero\sphinxhyphen{}based). If not in mesh, \sphinxtitleref{ind{[}i{]}=\sphinxhyphen{}1}. Size: (N,).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{int\_func} (\sphinxstyleemphasis{double NumPy array}) \textendash{} i\sphinxhyphen{}th row is the barycentric coordinates of i\sphinxhyphen{}th queried point. If not in mesh, corresponding row is all zero. Size: (N, dim+1).

\end{itemize}


\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
\sphinxurl{https://github.com/dengwirda/find-tria}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.pointTriangleDistance}
\label{\detokenize{_autosummary/nirfasterff.utils.pointTriangleDistance:nirfasterff-utils-pointtriangledistance}}\label{\detokenize{_autosummary/nirfasterff.utils.pointTriangleDistance::doc}}\index{pointTriangleDistance() (in module nirfasterff.utils)@\spxentry{pointTriangleDistance()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.pointTriangleDistance:nirfasterff.utils.pointTriangleDistance}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{pointTriangleDistance}}}
{\sphinxparam{\DUrole{n}{TRI}}\sphinxparamcomma \sphinxparam{\DUrole{n}{P}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the distance between a point and a triangle (defined by three points), and find the projection point
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TRI}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numpy array}}) \textendash{} The three points (per row) defining the triangle. Size: (3,3)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{P}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numpy array}}) \textendash{} point of query. Size (3,).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dist} (\sphinxstyleemphasis{double}) \textendash{} point\sphinxhyphen{}triangle distance.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{PP0} (\sphinxstyleemphasis{NumPy array}) \textendash{} projection point on the triangular face.

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
This is modified from Joshua Shaffer’s code, available at: \sphinxurl{https://gist.github.com/joshuashaffer/99d58e4ccbd37ca5d96e}

\sphinxAtStartPar
which is based on Gwendolyn Fischer’s Matlab code: \sphinxurl{https://uk.mathworks.com/matlabcentral/fileexchange/22857-distance-between-a-point-and-a-triangle-in-3d}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.uncompress\_coo}
\label{\detokenize{_autosummary/nirfasterff.utils.uncompress_coo:nirfasterff-utils-uncompress-coo}}\label{\detokenize{_autosummary/nirfasterff.utils.uncompress_coo::doc}}\index{uncompress\_coo() (in module nirfasterff.utils)@\spxentry{uncompress\_coo()}\spxextra{in module nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.uncompress_coo:nirfasterff.utils.uncompress_coo}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{uncompress\_coo}}}
{\sphinxparam{\DUrole{n}{compressed\_idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert compressed indices to COO.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{compressed\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int NumPy array}}) \textendash{} Input indices in compressed format, zero\sphinxhyphen{}based.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{coo\_idx} \textendash{} Output indices in COO format, zero\sphinxhyphen{}based.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int NumPy array

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConvergenceInfo}}}}}({[}info{]})
&
\sphinxAtStartPar
Convergence information of the FEM solvers.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshingParams}}}}}({[}xPixelSpacing, ...{]})
&
\sphinxAtStartPar
Parameters to be used by the CGAL mesher.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SolverOptions}}}}}({[}max\_iter, AbsoluteTolerance, ...{]})
&
\sphinxAtStartPar
Parameters used by the FEM solvers, Equivalent to \textquotesingle{}solver\_options\textquotesingle{} in the Matlab version
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.utils.ConvergenceInfo}
\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff-utils-convergenceinfo}}\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo::doc}}\index{ConvergenceInfo (class in nirfasterff.utils)@\spxentry{ConvergenceInfo}\spxextra{class in nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{ConvergenceInfo}}}
{\sphinxparam{\DUrole{n}{info}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Convergence information of the FEM solvers. Only used internally as a return type of functions nirfasterff.math.get\_field\_*

\sphinxAtStartPar
Constructed using the output of the internal C++ functions
\index{isConverged (nirfasterff.utils.ConvergenceInfo attribute)@\spxentry{isConverged}\spxextra{nirfasterff.utils.ConvergenceInfo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo.isConverged}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{isConverged}}}
\pysigstopsignatures
\sphinxAtStartPar
if solver converged to relative tolerance, for each rhs
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
bool array

\end{description}\end{quote}

\end{fulllineitems}

\index{isConvergedToAbsoluteTolerance (nirfasterff.utils.ConvergenceInfo attribute)@\spxentry{isConvergedToAbsoluteTolerance}\spxextra{nirfasterff.utils.ConvergenceInfo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo.isConvergedToAbsoluteTolerance}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{isConvergedToAbsoluteTolerance}}}
\pysigstopsignatures
\sphinxAtStartPar
if solver converged to absolute tolerance, for each rhs
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
bool array

\end{description}\end{quote}

\end{fulllineitems}

\index{iteration (nirfasterff.utils.ConvergenceInfo attribute)@\spxentry{iteration}\spxextra{nirfasterff.utils.ConvergenceInfo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo.iteration}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{iteration}}}
\pysigstopsignatures
\sphinxAtStartPar
iterations taken to converge, for each rhs
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int array

\end{description}\end{quote}

\end{fulllineitems}

\index{residual (nirfasterff.utils.ConvergenceInfo attribute)@\spxentry{residual}\spxextra{nirfasterff.utils.ConvergenceInfo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo.residual}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{residual}}}
\pysigstopsignatures
\sphinxAtStartPar
final residual, for each rhs
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double array

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.utils.ConvergenceInfo method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.utils.ConvergenceInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{\sphinxparam{\DUrole{n}{info}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.ConvergenceInfo:nirfasterff.utils.ConvergenceInfo.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}({[}info{]})
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.MeshingParams}
\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff-utils-meshingparams}}\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams::doc}}\index{MeshingParams (class in nirfasterff.utils)@\spxentry{MeshingParams}\spxextra{class in nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{MeshingParams}}}
{\sphinxparam{\DUrole{n}{xPixelSpacing}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{yPixelSpacing}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{SliceThickness}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{facet\_angle}\DUrole{o}{=}\DUrole{default_value}{25.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{facet\_size}\DUrole{o}{=}\DUrole{default_value}{3.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{facet\_distance}\DUrole{o}{=}\DUrole{default_value}{2.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cell\_radius\_edge}\DUrole{o}{=}\DUrole{default_value}{3.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{general\_cell\_size}\DUrole{o}{=}\DUrole{default_value}{3.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{subdomain}\DUrole{o}{=}\DUrole{default_value}{np.array({[}0., 0.{]})}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lloyd\_smooth}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Parameters to be used by the CGAL mesher. Note: they should all be double
\index{xPixelSpacing (nirfasterff.utils.MeshingParams attribute)@\spxentry{xPixelSpacing}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.xPixelSpacing}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{xPixelSpacing}}}
\pysigstopsignatures
\sphinxAtStartPar
voxel distance in x direction. Default: 1.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{yPixelSpacing (nirfasterff.utils.MeshingParams attribute)@\spxentry{yPixelSpacing}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.yPixelSpacing}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{yPixelSpacing}}}
\pysigstopsignatures
\sphinxAtStartPar
voxel distance in y direction. Default: 1.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{SliceThickness (nirfasterff.utils.MeshingParams attribute)@\spxentry{SliceThickness}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.SliceThickness}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{SliceThickness}}}
\pysigstopsignatures
\sphinxAtStartPar
voxel distance in z direction. Default: 1.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{facet\_angle (nirfasterff.utils.MeshingParams attribute)@\spxentry{facet\_angle}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.facet_angle}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{facet\_angle}}}
\pysigstopsignatures
\sphinxAtStartPar
lower bound for the angle (in degrees) of surface facets. Default: 25.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{facet\_size (nirfasterff.utils.MeshingParams attribute)@\spxentry{facet\_size}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.facet_size}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{facet\_size}}}
\pysigstopsignatures
\sphinxAtStartPar
upper bound for the radii of surface Delaunay balls circumscribing the facets. Default: 3.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{facet\_distance (nirfasterff.utils.MeshingParams attribute)@\spxentry{facet\_distance}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.facet_distance}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{facet\_distance}}}
\pysigstopsignatures
\sphinxAtStartPar
upper bound for the distance between the circumcenter of a surface facet and the center of its surface Delaunay ball. Default: 2.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{cell\_radius\_edge (nirfasterff.utils.MeshingParams attribute)@\spxentry{cell\_radius\_edge}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.cell_radius_edge}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{cell\_radius\_edge}}}
\pysigstopsignatures
\sphinxAtStartPar
upper bound for the ratio between the circumradius of a mesh tetrahedron and its shortest edge. Default: 3.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{general\_cell\_size (nirfasterff.utils.MeshingParams attribute)@\spxentry{general\_cell\_size}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.general_cell_size}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{general\_cell\_size}}}
\pysigstopsignatures
\sphinxAtStartPar
upper bound on the circumradii of the mesh tetrahedra, when no region\sphinxhyphen{}specific parameters (see below) are provided. Default: 3.0
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{subdomain (nirfasterff.utils.MeshingParams attribute)@\spxentry{subdomain}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.subdomain}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{subdomain}}}
\pysigstopsignatures
\sphinxAtStartPar
Specify cell size for each region, in format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{region\PYGZus{}label1}\PYG{p}{,} \PYG{n}{cell\PYGZus{}size1}\PYG{p}{]}
\PYG{p}{[}\PYG{n}{region\PYGZus{}label2}\PYG{p}{,} \PYG{n}{cell\PYGZus{}size2}\PYG{p}{]}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
If a region is not specified, value in “general\_cell\_size” will be used.  Default: np.array({[}0., 0.{]})
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{lloyd\_smooth (nirfasterff.utils.MeshingParams attribute)@\spxentry{lloyd\_smooth}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.lloyd_smooth}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{lloyd\_smooth}}}
\pysigstopsignatures
\sphinxAtStartPar
Switch for Lloyd smoother before local optimization. This can take up to 120s (hard limit set) but improves mesh quality. Default: True
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{offset (nirfasterff.utils.MeshingParams attribute)@\spxentry{offset}\spxextra{nirfasterff.utils.MeshingParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.offset}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{offset}}}
\pysigstopsignatures
\sphinxAtStartPar
offset value to be added to the nodes after meshing. Size (3,). Defualt: None
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double Numpy array

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Notes}

\sphinxAtStartPar
Refer to CGAL documentation for details of the meshing algorithm as well as its parameters

\sphinxAtStartPar
\sphinxurl{https://doc.cgal.org/latest/Mesh\_3/index.html\#Chapter\_3D\_Mesh\_Generation}
\index{\_\_init\_\_() (nirfasterff.utils.MeshingParams method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.utils.MeshingParams method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{\sphinxparam{\DUrole{n}{xPixelSpacing}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{yPixelSpacing}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{SliceThickness}\DUrole{o}{=}\DUrole{default_value}{1.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{facet\_angle}\DUrole{o}{=}\DUrole{default_value}{25.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{facet\_size}\DUrole{o}{=}\DUrole{default_value}{3.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{facet\_distance}\DUrole{o}{=}\DUrole{default_value}{2.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cell\_radius\_edge}\DUrole{o}{=}\DUrole{default_value}{3.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{general\_cell\_size}\DUrole{o}{=}\DUrole{default_value}{3.}}\sphinxparamcomma \sphinxparam{\DUrole{n}{subdomain}\DUrole{o}{=}\DUrole{default_value}{np.array({[}0., 0.{]})}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lloyd\_smooth}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.MeshingParams:nirfasterff.utils.MeshingParams.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}({[}xPixelSpacing, yPixelSpacing, ...{]})
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.utils.SolverOptions}
\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff-utils-solveroptions}}\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions::doc}}\index{SolverOptions (class in nirfasterff.utils)@\spxentry{SolverOptions}\spxextra{class in nirfasterff.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{nirfasterff.utils.}}\sphinxbfcode{\sphinxupquote{SolverOptions}}}
{\sphinxparam{\DUrole{n}{max\_iter}\DUrole{o}{=}\DUrole{default_value}{1000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{AbsoluteTolerance}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{RelativeTolerance}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{divergence}\DUrole{o}{=}\DUrole{default_value}{1e8}}\sphinxparamcomma \sphinxparam{\DUrole{n}{GPU}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Parameters used by the FEM solvers, Equivalent to ‘solver\_options’ in the Matlab version
\index{max\_iter (nirfasterff.utils.SolverOptions attribute)@\spxentry{max\_iter}\spxextra{nirfasterff.utils.SolverOptions attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions.max_iter}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{max\_iter}}}
\pysigstopsignatures
\sphinxAtStartPar
maximum number of iterations allowed. Default: 1000
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{AbsoluteTolerance (nirfasterff.utils.SolverOptions attribute)@\spxentry{AbsoluteTolerance}\spxextra{nirfasterff.utils.SolverOptions attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions.AbsoluteTolerance}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{AbsoluteTolerance}}}
\pysigstopsignatures
\sphinxAtStartPar
Absolute tolerance for convergence. Default: 1e\sphinxhyphen{}12
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{RelativeTolerance (nirfasterff.utils.SolverOptions attribute)@\spxentry{RelativeTolerance}\spxextra{nirfasterff.utils.SolverOptions attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions.RelativeTolerance}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{RelativeTolerance}}}
\pysigstopsignatures
\sphinxAtStartPar
Relative (to the initial residual norm) tolerance for convergence. Default: 1e\sphinxhyphen{}12
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{divergence (nirfasterff.utils.SolverOptions attribute)@\spxentry{divergence}\spxextra{nirfasterff.utils.SolverOptions attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions.divergence}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{divergence}}}
\pysigstopsignatures
\sphinxAtStartPar
Stop the solver when residual norm greater than this value. Default: 1e8
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
double

\end{description}\end{quote}

\end{fulllineitems}

\index{GPU (nirfasterff.utils.SolverOptions attribute)@\spxentry{GPU}\spxextra{nirfasterff.utils.SolverOptions attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions.GPU}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{GPU}}}
\pysigstopsignatures
\sphinxAtStartPar
GPU selection. \sphinxhyphen{}1 for automatic, 0, 1, … for manual selection on multi\sphinxhyphen{}GPU systems. Default: \sphinxhyphen{}1
\begin{quote}\begin{description}
\sphinxlineitem{Type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (nirfasterff.utils.SolverOptions method)@\spxentry{\_\_init\_\_()}\spxextra{nirfasterff.utils.SolverOptions method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions.__init__}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}
{\sphinxparam{\DUrole{n}{max\_iter}\DUrole{o}{=}\DUrole{default_value}{1000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{AbsoluteTolerance}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{RelativeTolerance}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}12}}\sphinxparamcomma \sphinxparam{\DUrole{n}{divergence}\DUrole{o}{=}\DUrole{default_value}{1e8}}\sphinxparamcomma \sphinxparam{\DUrole{n}{GPU}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}}
{}
\pysigstopsignatures
\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.utils.SolverOptions:nirfasterff.utils.SolverOptions.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}({[}max\_iter, AbsoluteTolerance, ...{]})
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{fulllineitems}


\sphinxstepscope


\subsection{nirfasterff.visualize}
\label{\detokenize{_autosummary/nirfasterff.visualize:module-nirfasterff.visualize}}\label{\detokenize{_autosummary/nirfasterff.visualize:nirfasterff-visualize}}\label{\detokenize{_autosummary/nirfasterff.visualize::doc}}\index{module@\spxentry{module}!nirfasterff.visualize@\spxentry{nirfasterff.visualize}}\index{nirfasterff.visualize@\spxentry{nirfasterff.visualize}!module@\spxentry{module}}
\sphinxAtStartPar
Functions for basic data visualization
\subsubsection*{Functions}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.visualize.plot3dmesh:nirfasterff.visualize.plot3dmesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot3dmesh}}}}}(mesh{[}, data, selector, alpha{]})
&
\sphinxAtStartPar
Fast preview of data within a 3D FEM mesh in the nirfasterff format.
\\
\sphinxhline
\sphinxAtStartPar
{\hyperref[\detokenize{_autosummary/nirfasterff.visualize.plotimage:nirfasterff.visualize.plotimage}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plotimage}}}}}(mesh{[}, data{]})
&
\sphinxAtStartPar
Fast preview of data within a 2D FEM mesh in the nirfasterff format.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsubsection{nirfasterff.visualize.plot3dmesh}
\label{\detokenize{_autosummary/nirfasterff.visualize.plot3dmesh:nirfasterff-visualize-plot3dmesh}}\label{\detokenize{_autosummary/nirfasterff.visualize.plot3dmesh::doc}}\index{plot3dmesh() (in module nirfasterff.visualize)@\spxentry{plot3dmesh()}\spxextra{in module nirfasterff.visualize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.visualize.plot3dmesh:nirfasterff.visualize.plot3dmesh}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.visualize.}}\sphinxbfcode{\sphinxupquote{plot3dmesh}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{selector}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{alpha}\DUrole{o}{=}\DUrole{default_value}{0.8}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fast preview of data within a 3D FEM mesh in the nirfasterff format.

\sphinxAtStartPar
Plots an image of the values on the mesh at the intersection specified by “selector”.

\sphinxAtStartPar
For 2D mesh, use {\hyperref[\detokenize{_autosummary/nirfasterff.visualize.plotimage:nirfasterff.visualize.plotimage}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plotimage()}}}}} instead
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff mesh type}}) \textendash{} a 3D nirfasterff mesh to plot the data on.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} data to be plotted, with size (NNode,). If not specified, treated as all zero.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{selector}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
\sphinxAtStartPar
Specifies the intersection at which the data will be plotted, e.g. ‘x\textgreater{}50’, or ‘(x\textgreater{}50) | (y\textless{}100)’, or ‘x + y + z \textless{} 200’.

\sphinxAtStartPar
Note that “=” is not supported. When “|” or “\&” are used, make sure that all conditions are put in parantheses separately

\sphinxAtStartPar
If not specified, function plots the outermost shell of the mesh.


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} transparency, between 0\sphinxhyphen{}1. Default is 0.8

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh not 2D.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{matplotlib.figure.Figure} \textendash{} the figure to be displayed

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{mpl\_toolkits.mplot3d.axes3d.Axes3D} \textendash{} Current axes of the plot. Can be subsequently used for further plotting.

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
This function is adapted from the ‘plotmesh’ function in the iso2mesh toolbox

\sphinxAtStartPar
\sphinxurl{https://iso2mesh.sourceforge.net/cgi-bin/index.cgi}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{nirfasterff.visualize.plotimage}
\label{\detokenize{_autosummary/nirfasterff.visualize.plotimage:nirfasterff-visualize-plotimage}}\label{\detokenize{_autosummary/nirfasterff.visualize.plotimage::doc}}\index{plotimage() (in module nirfasterff.visualize)@\spxentry{plotimage()}\spxextra{in module nirfasterff.visualize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_autosummary/nirfasterff.visualize.plotimage:nirfasterff.visualize.plotimage}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{nirfasterff.visualize.}}\sphinxbfcode{\sphinxupquote{plotimage}}}
{\sphinxparam{\DUrole{n}{mesh}}\sphinxparamcomma \sphinxparam{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fast preview of data within a 2D FEM mesh in the nirfasterff format.

\sphinxAtStartPar
Plots an image of the values on the mesh. For 3D mesh, use {\hyperref[\detokenize{_autosummary/nirfasterff.visualize.plot3dmesh:nirfasterff.visualize.plot3dmesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot3dmesh()}}}}} instead
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{nirfasterff mesh type}}) \textendash{} a 2D nirfasterff mesh to plot the data on.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{double NumPy vector}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} data to be plotted, with size (NNode,). If not specified, treated as all zero.

\end{itemize}

\sphinxlineitem{Raises}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if mesh not 2D.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{matplotlib.figure.Figure} \textendash{} the figure to be displayed

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{mpl\_toolkits.mplot3d.axes3d.Axes3D} \textendash{} Current axes of the plot. Can be subsequently used for further plotting.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{n}
\item\relax\sphinxstyleindexentry{nirfasterff}\sphinxstyleindexpageref{_autosummary/nirfasterff:\detokenize{module-nirfasterff}}
\item\relax\sphinxstyleindexentry{nirfasterff.base}\sphinxstyleindexpageref{_autosummary/nirfasterff.base:\detokenize{module-nirfasterff.base}}
\item\relax\sphinxstyleindexentry{nirfasterff.base.data}\sphinxstyleindexpageref{_autosummary/nirfasterff.base.data:\detokenize{module-nirfasterff.base.data}}
\item\relax\sphinxstyleindexentry{nirfasterff.base.dcs\_mesh}\sphinxstyleindexpageref{_autosummary/nirfasterff.base.dcs_mesh:\detokenize{module-nirfasterff.base.dcs_mesh}}
\item\relax\sphinxstyleindexentry{nirfasterff.base.fluor\_mesh}\sphinxstyleindexpageref{_autosummary/nirfasterff.base.fluor_mesh:\detokenize{module-nirfasterff.base.fluor_mesh}}
\item\relax\sphinxstyleindexentry{nirfasterff.base.optodes}\sphinxstyleindexpageref{_autosummary/nirfasterff.base.optodes:\detokenize{module-nirfasterff.base.optodes}}
\item\relax\sphinxstyleindexentry{nirfasterff.base.stnd\_mesh}\sphinxstyleindexpageref{_autosummary/nirfasterff.base.stnd_mesh:\detokenize{module-nirfasterff.base.stnd_mesh}}
\item\relax\sphinxstyleindexentry{nirfasterff.forward}\sphinxstyleindexpageref{_autosummary/nirfasterff.forward:\detokenize{module-nirfasterff.forward}}
\item\relax\sphinxstyleindexentry{nirfasterff.forward.analytical}\sphinxstyleindexpageref{_autosummary/nirfasterff.forward.analytical:\detokenize{module-nirfasterff.forward.analytical}}
\item\relax\sphinxstyleindexentry{nirfasterff.forward.femdata}\sphinxstyleindexpageref{_autosummary/nirfasterff.forward.femdata:\detokenize{module-nirfasterff.forward.femdata}}
\item\relax\sphinxstyleindexentry{nirfasterff.inverse}\sphinxstyleindexpageref{_autosummary/nirfasterff.inverse:\detokenize{module-nirfasterff.inverse}}
\item\relax\sphinxstyleindexentry{nirfasterff.io}\sphinxstyleindexpageref{_autosummary/nirfasterff.io:\detokenize{module-nirfasterff.io}}
\item\relax\sphinxstyleindexentry{nirfasterff.lib}\sphinxstyleindexpageref{_autosummary/nirfasterff.lib:\detokenize{module-nirfasterff.lib}}
\item\relax\sphinxstyleindexentry{nirfasterff.lib.nirfasterff\_cpu}\sphinxstyleindexpageref{_autosummary/nirfasterff.lib.nirfasterff_cpu:\detokenize{module-nirfasterff.lib.nirfasterff_cpu}}
\item\relax\sphinxstyleindexentry{nirfasterff.lib.nirfasterff\_cuda}\sphinxstyleindexpageref{_autosummary/nirfasterff.lib.nirfasterff_cuda:\detokenize{module-nirfasterff.lib.nirfasterff_cuda}}
\item\relax\sphinxstyleindexentry{nirfasterff.math}\sphinxstyleindexpageref{_autosummary/nirfasterff.math:\detokenize{module-nirfasterff.math}}
\item\relax\sphinxstyleindexentry{nirfasterff.meshing}\sphinxstyleindexpageref{_autosummary/nirfasterff.meshing:\detokenize{module-nirfasterff.meshing}}
\item\relax\sphinxstyleindexentry{nirfasterff.meshing.auxiliary}\sphinxstyleindexpageref{_autosummary/nirfasterff.meshing.auxiliary:\detokenize{module-nirfasterff.meshing.auxiliary}}
\item\relax\sphinxstyleindexentry{nirfasterff.meshing.meshutils}\sphinxstyleindexpageref{_autosummary/nirfasterff.meshing.meshutils:\detokenize{module-nirfasterff.meshing.meshutils}}
\item\relax\sphinxstyleindexentry{nirfasterff.utils}\sphinxstyleindexpageref{_autosummary/nirfasterff.utils:\detokenize{module-nirfasterff.utils}}
\item\relax\sphinxstyleindexentry{nirfasterff.visualize}\sphinxstyleindexpageref{_autosummary/nirfasterff.visualize:\detokenize{module-nirfasterff.visualize}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}