"""The FEM solvers. It is usually recommended to use the high-level wrappers in the mesh classes by calling the mesh.femdata* functions."""from nirfasterff import utilsfrom nirfasterff import mathfrom nirfasterff import baseimport numpy as npimport copyfrom scipy import signalfrom scipy import sparsedef femdata_stnd_CW(mesh, solver = utils.get_solver(), opt = utils.SolverOptions()):    """    Forward modeling for CW. Please consider using mesh.femdata(0) instead.        The function calculates the FEM MASS matrix, the source vectors, and calls the CW solver (preconditioned conjugated gradient).    Parameters    ----------    mesh : nirfasterff.base.stndmesh        the mesh used to calcuate the forward data.    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    Raises    ------    TypeError        If mesh is not a stnd mesh.    Returns    -------    data : nirfasterff.base.FDdata        fluence and boundary measurables given the mesh and optodes.                If mesh.vol is defined, the returned fluence will be in volumetric space                See :func:`~nirfasterff.base.data.FDdata` for details.    info : nirfasterff.utils.ConvergenceInfo        convergence information of the solver.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details            See Also    --------    :func:`~nirfasterff.math.get_field_CW()`, :func:`~nirfasterff.math.gen_mass_matrix()`, and :func:`~nirfasterff.math.gen_sources()`    """        if mesh.type != 'stnd':        raise TypeError('Only standard meshes supported')    # print("Calculating the MASS matrix", flush=1)    csrI, csrJ, csrV = math.gen_mass_matrix(mesh, 0., solver, opt.GPU)    qvec = math.gen_sources(mesh)    qvec = np.abs(qvec)    data = base.FDdata()    # print("Solving the system", flush=1)    data.phi, info = math.get_field_CW(csrI, csrJ, csrV, qvec, opt, solver)    data.complex = math.get_boundary_data(mesh, data.phi)    data.link = copy.deepcopy(mesh.link)    data.amplitude = np.abs(data.complex)    data.phase = np.zeros(data.complex.size)    data.phase[np.isnan(data.complex)] = np.nan    data.vol = copy.deepcopy(mesh.vol)        if len(mesh.vol.xgrid)>0:        if len(mesh.vol.zgrid)>0:            tmp = np.reshape(mesh.vol.mesh2grid.dot(data.phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, qvec.shape[1]), order='F')        else:            tmp = np.reshape(mesh.vol.mesh2grid.dot(data.phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, qvec.shape[1]), order='F')        data.phi = tmp        return data, infodef femdata_stnd_FD(mesh, freq, solver = utils.get_solver(), opt = utils.SolverOptions()):    """    Forward modeling for FD. Please consider using mesh.femdata(freq) instead. freq in Hz        The function calculates the MASS matrix, the source vectors, and calls the FD solver (preconditioned BiCGStab).    Parameters    ----------    mesh : nirfasterff.base.stndmesh        the mesh used to calcuate the forward data.    freq : double        modulation frequency in Hz.                 When it is 0, function continues with the BiCGstab solver, but generates a warning that the CW solver should be used for better performance    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    Raises    ------    TypeError        If mesh is not a stnd mesh.    Returns    -------    data : nirfasterff.base.FDdata        fluence and boundary measurables given the mesh and optodes.                If mesh.vol is defined, the returned fluence will be in volumetric space                See :func:`~nirfasterff.base.data.FDdata` for details.    info : nirfasterff.utils.ConvergenceInfo        convergence information of the solver.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details        See Also    --------    :func:`~nirfasterff.math.get_field_FD()`, :func:`~nirfasterff.math.gen_mass_matrix()`, and :func:`~nirfasterff.math.gen_sources()`    """        if mesh.type != 'stnd':        raise TypeError('Only standard meshes supported')    if freq==0:        print('Warning: Use femdata_stnd_CW for better performance')    freq = freq * 2 * np.pi    # print("Calculating the MASS matrix", flush=1)    csrI, csrJ, csrV = math.gen_mass_matrix(mesh, freq, solver, opt.GPU)    qvec = math.gen_sources(mesh)    data = base.FDdata()    # print("Solving the system", flush=1)    data.phi, info = math.get_field_FD(csrI, csrJ, csrV, qvec, opt, solver)    data.complex = math.get_boundary_data(mesh, data.phi)    data.link = copy.deepcopy(mesh.link)    data.amplitude = np.abs(data.complex)    data.phase = np.angle(data.complex)*180./np.pi    data.vol = copy.deepcopy(mesh.vol)        if len(mesh.vol.xgrid)>0:        if len(mesh.vol.zgrid)>0:            tmp = np.reshape(mesh.vol.mesh2grid.dot(data.phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, qvec.shape[1]), order='F')        else:            tmp = np.reshape(mesh.vol.mesh2grid.dot(data.phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, qvec.shape[1]), order='F')        data.phi = tmp        return data, infodef femdata_fl_CW(mesh, solver = utils.get_solver(), opt = utils.SolverOptions(), xflag=True, mmflag=True, flflag=True):    """    Forward modeling for CW in fluorescence meshes. Please consider using mesh.femdata(0) instead.        The function calculates the MASS matrices, the source vectors, and calls the CW solver (preconditioned conjugated gradient).        The optional flags can be used to determine which fields are calculated. By default all true.        Note that when flflag is set to True, xflag must also be True.    Parameters    ----------    mesh : nirfasterff.base.fluormesh        the mesh used to calcuate the forward data.    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    xflag : bool, optional        if intrinsic excitation field is calculated. The default is True.    mmflag : bool, optional        if intrinsic emission field is calculated. The default is True.    flflag : bool, optional        if fluorescence field is calculated. If set True, xflag must also be True. The default is True.    Raises    ------    TypeError        If mesh is not a fluor mesh.    ValueError        If flflag is set True but xflag is not.    Returns    -------    data : nirfasterff.base.FLdata        fluence and boundary measurables given the mesh and optodes.                If mesh.vol is defined, the returned fluences will be in volumetric space                See :func:`~nirfasterff.base.data.FLdata` for details.    infox : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, for intrinsic excitation.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details    infom : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, for intrinsic emission.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details    infofl : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, for fluorescence emission.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details        See Also    --------    :func:`~nirfasterff.math.get_field_CW()`, :func:`~nirfasterff.math.gen_mass_matrix()`, :func:`~nirfasterff.math.gen_sources()`, and :func:`~nirfasterff.math.gen_sources_fl()`    """        if mesh.type != 'fluor':        raise TypeError('Only fluorescence meshes supported')    if flflag and not xflag:        raise ValueError('Error: must first calculate excitation field before calculating fluorescence')        dummymesh = base.stndmesh()    dummymesh.nodes = copy.deepcopy(mesh.nodes)    dummymesh.elements = copy.deepcopy(mesh.elements)    dummymesh.bndvtx = copy.deepcopy(mesh.bndvtx)    dummymesh.mua = copy.deepcopy(mesh.muax)    dummymesh.kappa = copy.deepcopy(mesh.kappax)    dummymesh.ksi = copy.deepcopy(mesh.ksi)    dummymesh.c = copy.deepcopy(mesh.c)        data = base.FLdata()    data.link = copy.deepcopy(mesh.link)    # data.vol = copy.deepcopy(mesh.vol)        infox = None    infomm = None    infofl = None        if xflag:        # print("Calculating intrinsic data at excitation wavelength", flush=1)        csrIx, csrJx, csrVx = math.gen_mass_matrix(dummymesh, 0., solver, opt.GPU)        qvec = math.gen_sources(mesh)        qvec = np.abs(qvec)        data.phix, infox = math.get_field_CW(csrIx, csrJx, csrVx, qvec, opt, solver)        data.complexx = math.get_boundary_data(mesh, data.phix)        data.amplitudex = np.abs(data.complexx)        data.phasex = np.angle(data.complexx)*180./np.pi        data.phasex[np.isnan(data.complexx)] = np.nan    if mmflag:        # print("Calculating intrinsic data at emission wavelength", flush=1)        dummymesh.mua = copy.deepcopy(mesh.muam)        dummymesh.kappa = copy.deepcopy(mesh.kappam)                csrIm, csrJm, csrVm = math.gen_mass_matrix(dummymesh, 0., solver, opt.GPU)        if 'qvec' not in locals():            qvec = math.gen_sources(mesh)            qvec = np.abs(qvec)        data.phimm, infom = math.get_field_CW(csrIm, csrJm, csrVm, qvec, opt, solver)        data.complexmm = math.get_boundary_data(mesh, data.phimm)        data.amplitudemm = np.abs(data.complexmm)        data.phasemm = np.zeros(data.complexmm.size)        data.phasemm[np.isnan(data.complexmm)] = np.nan    if flflag:        # print("Calculating fluorescence data", flush=1)        if 'csrIm' not in locals():            dummymesh.mua = copy.deepcopy(mesh.muam)            dummymesh.kappa = copy.deepcopy(mesh.kappam)            csrIm, csrJm, csrVm = math.gen_mass_matrix(dummymesh, 0., solver, opt.GPU)        qvec = math.gen_sources_fl(mesh, data.phix, solver=solver)        data.phifl, infofl = math.get_field_CW(csrIm, csrJm, csrVm, qvec, opt, solver)        data.complexfl = math.get_boundary_data(mesh, data.phifl)        data.amplitudefl = np.abs(data.complexfl)        data.phasefl = np.zeros(data.complexfl.size)        data.phasefl[np.isnan(data.complexfl)] = np.nan        if mesh.isvol():        data.togrid(mesh)        return data, infox, infomm, infofldef femdata_fl_FD(mesh, freq, solver = utils.get_solver(), opt = utils.SolverOptions(), xflag=True, mmflag=True, flflag=True):    """    Forward modeling for FD in fluorescence meshes. Please consider using mesh.femdata(frequency) instead.        The function calculates the MASS matrix, the source vectors, and calls the FD solver (preconditioned BiCGStab).        The optional flags can be used to determine which fields are calculated. By default all true.        Note that when flflag is set to True, xflag must also be True.    Parameters    ----------    mesh : nirfasterff.base.stndmesh        the mesh used to calcuate the forward data.    freq : double        modulation frequency in Hz.                 When it is 0, function continues with the BiCGstab solver, but generates a warning that the CW solver should be used for better performance    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    xflag : bool, optional        if intrinsic excitation field is calculated. The default is True.    mmflag : bool, optional        if intrinsic emission field is calculated. The default is True.    flflag : bool, optional        if fluorescence field is calculated. If set True, xflag must also be True. The default is True.    Raises    ------    TypeError        If mesh is not a fluor mesh.    ValueError        If flflag is set True but xflag is not.    Returns    -------    data : nirfasterff.base.FLdata        fluence and boundary measurables given the mesh and optodes.                If mesh.vol is defined, the returned fluences will be in volumetric space                See :func:`~nirfasterff.base.data.FLdata` for details.    infox : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, for intrinsic excitation.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details    infom : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, for intrinsic emission.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details    infofl : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, for fluorescence emission.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details        See Also    --------    :func:`~nirfasterff.math.get_field_FD()`, :func:`~nirfasterff.math.gen_mass_matrix()`, :func:`~nirfasterff.math.gen_sources()`, and :func:`~nirfasterff.math.gen_sources_fl()`    """        if mesh.type != 'fluor':        raise TypeError('Only fluorescence meshes supported')    if flflag and not xflag:        raise ValueError('Error: must first calculate excitation field before calculating fluorescence')    if freq==0:        print('Warning: Use femdata_stnd_CW for better performance')            dummymesh = base.stndmesh()    dummymesh.nodes = copy.deepcopy(mesh.nodes)    dummymesh.elements = copy.deepcopy(mesh.elements)    dummymesh.bndvtx = copy.deepcopy(mesh.bndvtx)    dummymesh.mua = copy.deepcopy(mesh.muax)    dummymesh.kappa = copy.deepcopy(mesh.kappax)    dummymesh.ksi = copy.deepcopy(mesh.ksi)    dummymesh.c = copy.deepcopy(mesh.c)        data = base.FLdata()    data.link = copy.deepcopy(mesh.link)    # data.vol = copy.deepcopy(mesh.vol)        infox = None    infomm = None    infofl = None        omega = 2.0 * np.pi * freq    if xflag:        # print("Calculating intrinsic data at excitation wavelength", flush=1)        csrIx, csrJx, csrVx = math.gen_mass_matrix(dummymesh, omega, solver, opt.GPU)        qvec = math.gen_sources(mesh)        data.phix, infox = math.get_field_FD(csrIx, csrJx, csrVx, qvec, opt, solver)        data.complexx = math.get_boundary_data(mesh, data.phix)        data.amplitudex = np.abs(data.complexx)        data.phasex = np.zeros(data.complexx.size)        data.phasex[np.isnan(data.complexx)] = np.nan    if mmflag:        # print("Calculating intrinsic data at emission wavelength", flush=1)        dummymesh.mua = copy.deepcopy(mesh.muam)        dummymesh.kappa = copy.deepcopy(mesh.kappam)                csrIm, csrJm, csrVm = math.gen_mass_matrix(dummymesh, omega, solver, opt.GPU)        if 'qvec' not in locals():            qvec = math.gen_sources(mesh)        data.phimm, infom = math.get_field_FD(csrIm, csrJm, csrVm, qvec, opt, solver)        data.complexmm = math.get_boundary_data(mesh, data.phimm)        data.amplitudemm = np.abs(data.complexmm)        data.phasemm = np.angle(data.complexmm)*180./np.pi        data.phasemm[np.isnan(data.complexmm)] = np.nan    if flflag:        # print("Calculating fluorescence data", flush=1)        if 'csrIm' not in locals():            dummymesh.mua = copy.deepcopy(mesh.muam)            dummymesh.kappa = copy.deepcopy(mesh.kappam)            csrIm, csrJm, csrVm = math.gen_mass_matrix(dummymesh, omega, solver, opt.GPU)        qvec = math.gen_sources_fl(mesh, data.phix, freq, solver, opt.GPU)        data.phifl, infofl = math.get_field_FD(csrIm, csrJm, csrVm, qvec, opt, solver)        data.complexfl = math.get_boundary_data(mesh, data.phifl)        data.amplitudefl = np.abs(data.complexfl)        data.phasefl = np.angle(data.complexfl)*180./np.pi        data.phasefl[np.isnan(data.complexfl)] = np.nan        if mesh.isvol():        data.togrid(mesh)        return data, infox, infomm, infofldef femdata_stnd_TR(mesh, tmax, dt, savefield=False, beautify=True, solver = utils.get_solver(), opt = utils.SolverOptions()):    """    Forward modeling calculating TPSF on a standard mesh. Please consider using mesh.femdata_tpsf(tmax, dt) instead.        The function calculates the MASS matrices, the source vectors, and calls the standard TPSF solver (preconditioned conjugated gradient).    Parameters    ----------    mesh : nirfasterff.base.stndmesh        the mesh used to calcuate the forward data.    tmax : double        maximum time simulated, in seconds.    dt : double        size of each time step, in seconds.    savefield : bool, optional        If True, the internal TPSFs are also returned. If False, only boundary TPSFs are returned and data.phi will be empty.                 The default is False.    beautify : bool, optional        If true, zeros the initial unstable parts of the boundary TPSFs. The default is True.    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    Raises    ------    TypeError        If mesh is not a stnd mesh.    ValueError        If tmax is smaller than dt    Returns    -------    data : nirfasterff.base.TPSFdata        internal and boundary TPSFs given the mesh and optodes.                If mesh.vol is defined and `savefield==True`, the returned internal TPSFs will be in volumetric space                See :func:`~nirfasterff.base.data.TPSFdata` for details.    info : nirfasterff.utils.ConvergenceInfo        convergence information of the solver.                 Only the convergence info of the last time step is returned.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details            See Also    -------    :func:`~nirfasterff.math.gen_mass_matrix()`, :func:`~nirfasterff.math.gen_sources()`, and :func:`~nirfasterff.math.get_field_TR()`    """        if mesh.type != 'stnd':        raise TypeError('Only standard meshes supported')    if tmax<dt:        raise ValueError('tmax must be greater than dt')    # print("Calculating the MASS matrix", flush=1)    csrI, csrJ, csrV = math.gen_mass_matrix(mesh, 1., solver, opt.GPU)    qvec = math.gen_sources(mesh)    qvec = np.abs(qvec)    data = base.TPSFdata()    # print("Solving the system", flush=1)    data.time = np.arange(0., tmax*1.0, dt*1.0)    time_steps = len(data.time)    phi, info = math.get_field_TR(csrI, csrJ, csrV, qvec, dt*1.0, time_steps, opt, solver)    data.tpsf = np.zeros((mesh.link.shape[0], time_steps))    n_src = mesh.source.num.size    for i in range(time_steps):        data.tpsf[:,i] = math.get_boundary_data(mesh, phi[:, n_src*i:n_src*(i+1)])    data.link = copy.deepcopy(mesh.link)    # data.vol = copy.deepcopy(mesh.vol)        # Make it nice    if beautify:        rsd = np.linalg.norm(mesh.source.coord[mesh.link[:,0]-1,:] - mesh.meas.coord[mesh.link[:,1]-1,:], axis=1)        t_cut = rsd / np.mean(mesh.c)                for ind_pair in range(data.tpsf.shape[0]):            if not np.isnan(data.tpsf[ind_pair,0]):                # set zeroes at time of flight shorter than minumum possible time of flight between source and detector                 data.tpsf[ind_pair, data.time <= t_cut[ind_pair]] = 0.                # Set unstable part to zero                maxl = np.argmax(data.tpsf[ind_pair,:])                ind_sample = maxl                while ind_sample>=0:                    if data.tpsf[ind_pair, ind_sample] <= 0:                        break                    ind_sample -= 1                data.tpsf[ind_pair, 0:ind_sample+1] = 0.        if savefield:        if mesh.isvol():            if len(mesh.vol.zgrid)>0:                tmp = np.reshape(mesh.vol.mesh2grid.dot(phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, -1, time_steps), order='F')            else:                tmp = np.reshape(mesh.vol.mesh2grid.dot(phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, -1, time_steps), order='F')            data.phi = tmp        else:            data.phi = np.reshape(phi, (mesh.nodes.shape[0],-1,time_steps),order='F')    data.vol = copy.deepcopy(mesh.vol)    return data, infodef femdata_stnd_TR_moments(mesh, max_moments=3, savefield=False, solver = utils.get_solver(), opt = utils.SolverOptions()):    """    Forward modeling calculating TR moments using Mellin transform on a standard mesh. Please consider using mesh.femdata_moments() instead.        The function calculates the MASS matrices, the source vectors, and calls the Mellin moments solver (preconditioned conjugated gradient).        Calculates 0th, 1st, 2nd, .., max_moments-th moments directly without calculating TPSF first.        This is more efficient, if the actual TPSFs are not of concern.    Parameters    ----------    mesh : nirfasterff.base.stndmesh        the mesh used to calcuate the forward data.    max_moments : int32, optional        max order of moments to calculate. That is, 0th, 1st, 2nd, .., max_moments-th will be calculated. The default is 3.    savefield : bool, optional        If True, the internal moments are also returned. If False, only boundary moments are returned and data.phi will be empty.                 The default is False.    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    Raises    ------    TypeError        If mesh is not a stnd mesh.    ValueError        If max_moments is negative.    Returns    -------    data : nirfasterff.base.TRMomentsdata        internal and boundary moments given the mesh and optodes.                If mesh.vol is defined and `savefield==True`, the returned internal moments will be in volumetric space                See :func:`~nirfasterff.base.data.TRMomentsdata` for details.    info : nirfasterff.utils.ConvergenceInfo        convergence information of the solver.                 Only the convergence info of highest order moments is returned.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details        See Also    -------    :func:`~nirfasterff.math.gen_mass_matrix()`, :func:`~nirfasterff.math.gen_sources()`, and :func:`~nirfasterff.math.get_field_TRmoments()`        References    -------    Arridge and Schweiger, Applied Optics, 1995. doi:10.1364/AO.34.002683    """        if mesh.type != 'stnd':        raise TypeError('Only standard meshes supported')    if max_moments<0:        raise ValueError('max_moments must be non-negative')    # print("Calculating the MASS matrix", flush=1)    csrI, csrJ, csrV = math.gen_mass_matrix(mesh, 1., solver, opt.GPU)    qvec = math.gen_sources(mesh)    qvec = np.abs(qvec)    data = base.TRMomentsdata()    # print("Solving the system", flush=1)    phi, info = math.get_field_TRmoments(csrI, csrJ, csrV, qvec, max_moments, opt, solver)        n_src = mesh.source.num.size    m0 = phi[:,:n_src]    for ind_order in range(max_moments):        phi[:,n_src*(ind_order+1):n_src*(ind_order+2)] = phi[:,n_src*(ind_order+1):n_src*(ind_order+2)] / m0            data.moments = np.zeros((mesh.link.shape[0], max_moments+1))    for i in range(max_moments+1):        data.moments[:,i] = math.get_boundary_data(mesh, phi[:, n_src*i:n_src*(i+1)])    data.link = copy.deepcopy(mesh.link)    # data.vol = copy.deepcopy(mesh.vol)        if savefield:        if mesh.isvol():            if len(mesh.vol.zgrid)>0:                tmp = np.reshape(mesh.vol.mesh2grid.dot(phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, -1, max_moments+1), order='F')            else:                tmp = np.reshape(mesh.vol.mesh2grid.dot(phi), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, -1, max_moments+1), order='F')            data.phi = tmp        else:            data.phi = phi    data.vol = copy.deepcopy(mesh.vol)    return data, infodef femdata_DCS(mesh, tvec, solver = utils.get_solver(), opt = utils.SolverOptions()):    """    Forward modeling calculating steady-state fluences and G1/g1 curves by solving the correlation diffusion equation. Please consider using mesh.femdata(tvec) instead.        The fluences as well as its boundary amplitudes are exactly the same as what the CW solver would give when tau=0.        g1 curve is simple G1 curve normalized by the boundary amplitudes.        The function calculates the MASS matrices, the source vectors, and calls the G1 solver, which internally utilizes the CW solver.        When calculating the flow-related term, the function assumes Brownian motion and uses only mesh.aDb (that is, mesh.a and mesh.Db are ignored).        This is to say, we assume :math:`\\langle\\Delta r^2\\rangle=6\\alpha Db\\tau`    Parameters    ----------    mesh : nirfasterff.base.dcsmesh        the mesh used to calcuate the forward data.    tvec : double NumPy array        time vector (i.e. :math:`\tau`) for the G1 curve, in seconds. It is usually a good idea to use log scale    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    Raises    ------    TypeError        if mesh is not a dcs mesh.    Returns    -------    data : nirfasterff.base.DCSdata        contains fluence, G1 curve, and g1 curve calculated at each spatial location, and also the boundary data.                If mesh.vol is set, internal G1 curves will be returned in volumetric space                See :func:`~nirfasterff.base.data.DCSdata` for details.    info : nirfasterff.utils.ConvergenceInfo        convergence information of the solver when calculating the fluence field.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details        See Also    -------    :func:`~nirfasterff.math.gen_mass_matrix()`, :func:`~nirfasterff.math.gen_sources()`, and :func:`~nirfasterff.math.get_field_CW()`        References    -------    Durduran et al, 2010, Rep. Prog. Phys. doi:10.1088/0034-4885/73/7/076701    """    if mesh.type != 'dcs':        raise TypeError('Only DCS meshes supported')    # make a copy, so we don't accidentally make a mess    mesh2 = base.dcsmesh()    mesh2.from_copy(mesh)    mesh2.type = 'stnd' # pretend to be stnd, otherwise function refused to run    mesh2.vol = base.meshvol()    # steady state data    data0, info = femdata_stnd_CW(mesh2, solver, opt)    nsteps = np.size(tvec)    k0 = 2*np.pi / (mesh.wv_DCS/1e6)    # wavenumber; wavelength converted to mm    data = base.DCSdata()    data.phi = copy.deepcopy(data0.phi)    data.link = copy.deepcopy(data0.link)    data.amplitude = copy.deepcopy(data0.amplitude)    # data.vol = copy.deepcopy(mesh.vol)    data.tau_DCS = copy.deepcopy(tvec)    data.phi_DCS = np.zeros((mesh.nodes.shape[0], mesh.source.num.size, nsteps))    data.G1_DCS = np.zeros((mesh.link.shape[0], nsteps))        qvec = math.gen_sources(mesh)    qvec = np.abs(qvec)    for i in range(nsteps):        mesh2.mua = mesh.mua + 2*mesh.mus*k0*k0*mesh.aDb*tvec[i]        # Directly call the low-level solvers to avoid unnecessary copying etc        csrI, csrJ, csrV = math.gen_mass_matrix(mesh2, 0., solver, opt.GPU)        data.phi_DCS[:,:,i],_ = math.get_field_CW(csrI, csrJ, csrV, qvec, opt, solver)        data.G1_DCS[:,i] = math.get_boundary_data(mesh, data.phi_DCS[:,:,i])    data.g1_DCS = data.G1_DCS / data.amplitude[:,None]    if mesh.isvol():        data.togrid(mesh)        return data, infodef femdata_fl_TR(mesh, tmax, dt, savefield=False, beautify=True, solver = utils.get_solver(), opt = utils.SolverOptions()):    """    Forward modeling calculating TPSF on a fluorescence mesh. Please consider using mesh.femdata_tpsf(tmax, dt) instead.        The function calculates the MASS matrices, the source vectors, and calls two separate TPSF solvers (both preconditioned conjugated gradient):        First time calculates the TPSF for the excitation field, the result of which is consequently convolved with the decay.        The second solver is called with the convolved excitation field as its input to calculate the TPSF for fluorescence emission.    Parameters    ----------     mesh : nirfasterff.base.fluormesh        the mesh used to calcuate the forward data.    tmax : double        maximum time simulated, in seconds.    dt : double        size of each time step, in seconds.    savefield : bool, optional        If True, the internal TPSFs are also returned. If False, only boundary TPSFs are returned and data.phix and data.phifl will be empty.                 The default is False.    beautify : bool, optional        If true, zeros the initial unstable parts of the boundary TPSFs. The default is True.    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    Raises    ------    TypeError        if mesh is not a fluor mesh.    Returns    -------    data : nirfasterff.base.flTPSFdata        internal and boundary TPSFs given the mesh and optodes, both excitation and fluorescence emission.                If `mesh.vol` is set and `savefield` is set to `True`, internal TPSF data will be represented in volumetric space                See :func:`~nirfasterff.base.data.flTPSFdata` for details.    infox : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, excitation.                 Only the convergence info of the last time step is returned.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details    infom : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, fluorescence emission.                 Only the convergence info of the last time step is returned.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details        See Also    --------    :func:`~nirfasterff.math.gen_mass_matrix()`, :func:`~nirfasterff.math.get_field_TR()`, and :func:`~nirfasterff.math.get_field_TRFL()`    """    if mesh.type != 'fluor':        raise TypeError('Only fluorescence meshes supported')    # create a tmp stnd mesh, so we can run the mass matrix generation    dummymesh = base.stndmesh()    dummymesh.nodes = copy.deepcopy(mesh.nodes)    dummymesh.elements = copy.deepcopy(mesh.elements)    dummymesh.bndvtx = copy.deepcopy(mesh.bndvtx)    dummymesh.mua = copy.deepcopy(mesh.muax)    dummymesh.kappa = copy.deepcopy(mesh.kappax)    dummymesh.ksi = copy.deepcopy(mesh.ksi)    dummymesh.c = copy.deepcopy(mesh.c)    # MASS matrix at excitation wavelength    csrIx, csrJx, csrVx = math.gen_mass_matrix(dummymesh, 1., solver, opt.GPU)    qvec = math.gen_sources(mesh)    qvec = np.abs(qvec)    # Genererate excitation data    print('Excitation...', flush=1)    time = np.arange(0., tmax*1.0, dt*1.0)    time_steps = len(time)    phix, infox = math.get_field_TR(csrIx, csrJx, csrVx, qvec, dt*1.0, time_steps, opt, solver)    # boundary data    tpsfx = np.zeros((mesh.link.shape[0], time_steps))    n_src = mesh.source.num.size    for i in range(time_steps):        tpsfx[:,i] = math.get_boundary_data(mesh, phix[:, n_src*i:n_src*(i+1)])        # phix = np.reshape(phix, (-1,n_src,time_steps),order='F')    # Now emission: need to calcuate for each source    dummymesh.mua = copy.deepcopy(mesh.muam)    dummymesh.kappa = copy.deepcopy(mesh.kappam)    # MASS matrix at emission wavelength    print('Emission...', flush=1)    csrIm, csrJm, csrVm = math.gen_mass_matrix(dummymesh, 1., solver, opt.GPU)    # Now convolve phix with the decay    n_nodes = mesh.nodes.shape[0]    eta_muaf = mesh.eta * mesh.muaf    phim = np.zeros(phix.shape)    tmp_qm = np.zeros(phix.shape)    for src in range(n_src):        for i in range(n_nodes):            if eta_muaf[i]!=0 and not np.isnan(eta_muaf[i]):                if mesh.tau[i]==0:                    tmp_qm[i, src::n_src]= phix[i, src::n_src].squeeze() * eta_muaf[i]                else:                    decay = np.exp(-time/mesh.tau[i])                    tmp_qm[i, src::n_src] = signal.lfilter(decay, 1., phix[i, src::n_src].squeeze()) * eta_muaf[i] * dt/mesh.tau[i]    # Must perform the FEM integration: the matrix happens to be a CW MASS matrix when kappa=0, mua=1, and bndvtx=0 every where    nnodes = mesh.bndvtx.size    dummymesh.bndvtx = np.zeros(nnodes)    dummymesh.mua = np.ones(nnodes)    dummymesh.kappa = np.zeros(nnodes)    csrIint, csrJint, csrVint = math.gen_mass_matrix(dummymesh, 0., solver, opt.GPU)    MASSint = sparse.csr_matrix((csrVint, csrJint, csrIint), shape=(nnodes, nnodes))    qvec_m = MASSint @ tmp_qm        # Call the emission solver    phim, infom = math.get_field_TRFL(csrIm, csrJm, csrVm, qvec_m, dt*1.0, time_steps, opt, solver)    # boudary data, emission    tpsfm = np.zeros((mesh.link.shape[0], time_steps))    for i in range(time_steps):        tpsfm[:,i] = math.get_boundary_data(mesh, phim[:, n_src*i:n_src*(i+1)])    # Make it nice    if beautify:        rsd = np.linalg.norm(mesh.source.coord[mesh.link[:,0]-1,:] - mesh.meas.coord[mesh.link[:,1]-1,:], axis=1)        t_cut = rsd / np.mean(mesh.c)                for ind_pair in range(tpsfx.shape[0]):            if not np.isnan(tpsfx[ind_pair,0]):                # set zeroes at time of flight shorter than minumum possible time of flight between source and detector                 tpsfx[ind_pair, time <= t_cut[ind_pair]] = 0.                # Set unstable part to zero                maxl = np.argmax(tpsfx[ind_pair,:])                ind_sample = maxl                while ind_sample>=0:                    if tpsfx[ind_pair, ind_sample] <= 0:                        break                    ind_sample -= 1                tpsfx[ind_pair, 0:ind_sample+1]=0.            if not np.isnan(tpsfm[ind_pair,0]):                # set zeroes at time of flight shorter than minumum possible time of flight between source and detector                 tpsfm[ind_pair, time <= t_cut[ind_pair]] = 0.                # Set unstable part to zero                maxl = np.argmax(tpsfm[ind_pair,:])                ind_sample = maxl                while ind_sample>=0:                    if tpsfm[ind_pair, ind_sample] <= 0:                        break                    ind_sample -= 1                tpsfm[ind_pair, 0:ind_sample+1]=0.    # Assemble the data class to return    data = base.flTPSFdata()    if savefield:        if mesh.isvol():            if len(mesh.vol.zgrid)>0:                tmpx = np.reshape(mesh.vol.mesh2grid.dot(phix), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, -1, time_steps), order='F')                tmpm = np.reshape(mesh.vol.mesh2grid.dot(phim), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, -1, time_steps), order='F')            else:                tmpx = np.reshape(mesh.vol.mesh2grid.dot(phix), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, -1, time_steps), order='F')                tmpm = np.reshape(mesh.vol.mesh2grid.dot(phim), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, -1, time_steps), order='F')            data.phix = tmpx            data.phifl = tmpm        else:            data.phix = np.reshape(phix, (mesh.nodes.shape[0],-1,time_steps),order='F')            data.phifl = np.reshape(phim, (mesh.nodes.shape[0],-1,time_steps),order='F')    data.tpsfx = tpsfx    data.tpsffl = tpsfm    data.vol = copy.deepcopy(mesh.vol)    data.time = time    data.link = copy.deepcopy(mesh.link)    #return    return data, infox, infomdef femdata_fl_TR_moments(mesh, max_moments=3, savefield=False, solver = utils.get_solver(), opt = utils.SolverOptions()):    """    Forward modeling calculating TR moments using Mellin transform on a fluorescence mesh. Please consider using mesh.femdata_moments() instead.        The function calculates the MASS matrix, the source vectors, and calls the two Mellin moments solver (both preconditioned conjugated gradient):        First time calculates the moments for the excitation field, the result of which is consequently used as the input of the second solver,        which calculates the moments of fluorescence emission based on the excitation moments        Calculates 0th, 1st, 2nd, .., max_moments-th moments directly without calculating TPSF first, and this is done for both excitation and fluorescence emission.        This is more efficient, if the time series are not of concern.    Parameters    ----------    mesh : nirfasterff.base.fluormesh        the mesh used to calculate the forward data.    max_moments : int32, optional        max order of moments to calculate. That is, 0th, 1st, 2nd, .., max_moments-th will be calculated. The default is 3.    savefield : bool, optional        If True, the internal moments are also returned. If False, only boundary moments are returned and data.phix and data.phifl will be empty.                 The default is False.    solver : str, optional        Choose between 'CPU' or 'GPU' solver (case insensitive). Automatically determined (GPU prioritized) if not specified    opt : nirfasterff.utils.SolverOptions, optional        Solver options. Uses default parameters if not specified, and they should suffice in most cases.                 See :func:`~nirfasterff.utils.SolverOptions` for details    Raises    ------    TypeError        if mesh is not a fluor mesh.    ValueError        if max_moments is negative.    Returns    -------    data : nirfasterff.base.flTRMomentsdata        internal and boundary moments given the mesh and optodes, both excitation and fluorescence emission.                If `mesh.vol` is set and `savefield` is set to `True`, internal moments will be represented in volumetric space                See :func:`~nirfasterff.base.data.flTRMomentsdata` for details.    infox : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, excitation.                 Only the convergence info of highest order moments is returned.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details    infom : nirfasterff.utils.ConvergenceInfo        convergence information of the solver, fluorescence emission.                 Only the convergence info of highest order moments is returned.                See :func:`~nirfasterff.utils.ConvergenceInfo` for details        See Also    -------    :func:`~nirfasterff.math.gen_mass_matrix()`, :func:`~nirfasterff.math.get_field_TRmoments()`, and :func:`~nirfasterff.math.get_field_TRFLmoments()`    """       if mesh.type != 'fluor':        raise TypeError('Only standard meshes supported')    if max_moments<0:        raise ValueError('max_moments must be non-negative')    # create a tmp stnd mesh, so we can run the mass matrix generation    dummymesh = base.stndmesh()    dummymesh.nodes = copy.deepcopy(mesh.nodes)    dummymesh.elements = copy.deepcopy(mesh.elements)    dummymesh.bndvtx = copy.deepcopy(mesh.bndvtx)    dummymesh.mua = copy.deepcopy(mesh.muax)    dummymesh.kappa = copy.deepcopy(mesh.kappax)    dummymesh.ksi = copy.deepcopy(mesh.ksi)    dummymesh.c = copy.deepcopy(mesh.c)    # MASS matrix at excitation wavelength    csrIx, csrJx, csrVx = math.gen_mass_matrix(dummymesh, 1., solver, opt.GPU)    qvec = math.gen_sources(mesh)    qvec = np.abs(qvec)    # excitation moments    phix, infox = math.get_field_TRmoments(csrIx, csrJx, csrVx, qvec, max_moments, opt, solver)    # Now emission: need to calcuate for each source    dummymesh.mua = copy.deepcopy(mesh.muam)    dummymesh.kappa = copy.deepcopy(mesh.kappam)    # MASS matrix at emission wavelength    csrIm, csrJm, csrVm = math.gen_mass_matrix(dummymesh, 1., solver, opt.GPU)    # Must perform the FEM integration: the matrix happens to be a CW MASS matrix when kappa=0, mua=1, and bndvtx=0 every where    nnodes = mesh.bndvtx.size    dummymesh.bndvtx = np.zeros(nnodes)    dummymesh.mua = np.ones(nnodes)    dummymesh.kappa = np.zeros(nnodes)    csrIint, csrJint, csrVint = math.gen_mass_matrix(dummymesh, 0., solver, opt.GPU)    # MASSint = sparse.csr_matrix((csrVint, csrJint, csrIint), shape=(nnodes, nnodes))    # mx_fem = MASSint @ phix    # Calculate the emission moments    gamma = np.float64(mesh.eta * mesh.muaf)    tau = np.float64(mesh.tau)    phifl, infofl = math.get_field_TRFLmoments(csrIm, csrJm, csrVm, csrVint, phix, gamma, tau, max_moments, opt, solver)        n_src = mesh.source.num.size    mx0 = phix[:,:n_src]    mfl0 = phifl[:,:n_src]    for ind_order in range(max_moments):        phix[:,n_src*(ind_order+1):n_src*(ind_order+2)] = phix[:,n_src*(ind_order+1):n_src*(ind_order+2)] / mx0        phifl[:,n_src*(ind_order+1):n_src*(ind_order+2)] = phifl[:,n_src*(ind_order+1):n_src*(ind_order+2)] / mfl0            data = base.flTRMomentsdata()    data.momentsx = np.zeros((mesh.link.shape[0], max_moments+1))    data.momentsfl = np.zeros((mesh.link.shape[0], max_moments+1))    for i in range(max_moments+1):        data.momentsx[:,i] = math.get_boundary_data(mesh, phix[:, n_src*i:n_src*(i+1)])        data.momentsfl[:,i] = math.get_boundary_data(mesh, phifl[:, n_src*i:n_src*(i+1)])    data.link = copy.deepcopy(mesh.link)    data.vol = copy.deepcopy(mesh.vol)        if savefield:        if mesh.isvol():            if len(mesh.vol.zgrid)>0:                tmpx = np.reshape(mesh.vol.mesh2grid.dot(phix), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, -1, max_moments+1), order='F')                tmpfl = np.reshape(mesh.vol.mesh2grid.dot(phifl), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, mesh.vol.zgrid.size, -1, max_moments+1), order='F')            else:                tmpx = np.reshape(mesh.vol.mesh2grid.dot(phix), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, -1, max_moments+1), order='F')                tmpfl = np.reshape(mesh.vol.mesh2grid.dot(phifl), (mesh.vol.ygrid.size, mesh.vol.xgrid.size, -1, max_moments+1), order='F')            data.phix = tmpx            data.phifl = tmpfl        else:            data.phix = np.reshape(phix, (mesh.nodes.shape[0],-1,max_moments+1),order='F')            data.phifl = np.reshape(phifl, (mesh.nodes.shape[0],-1,max_moments+1),order='F')        return data, infox, infofl