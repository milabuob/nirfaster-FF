"""
Some functions for reading/writing certain data types. 

As of now, they are only used by the CGAL mesher, and there should be no need for the user to directly call them.
"""
import numpy as np

def saveinr(vol, fname, xPixelSpacing=1., yPixelSpacing=1., SliceThickness=1.):
    """
    Save a volume in the INRIA format. This is for the CGAL mesher.
    
    Directly translated from the Matlab version

    Parameters
    ----------
    vol : NumPy array
        the volume to be saved.
    fname : str
        file name to be saved as.
    xPixelSpacing : double, optional
        volume resolution in x direction. The default is 1..
    yPixelSpacing : double, optional
        volume resolution in y direction. The default is 1..
    SliceThickness : double, optional
        volume resolution in z direction. The default is 1..

    Returns
    -------
    None.

    """

    if not '.inr' in fname:
        fname = fname + '.inr'
    if vol.dtype == 'bool' or vol.dtype == 'uint8':
        btype = 'unsigned fixed'
        bitlen = 8
    elif vol.dtype == 'uint16':
        btype = 'unsigned fixed'
        bitlen = 16
    elif vol.dtype == 'float32':
        btype = 'float'
        bitlen = 32
    elif vol.dtype == 'float64':
        btype = 'float'
        bitlen = 64
    else:
        print('volume format not supported')
        return
        
    header = '#INRIMAGE-4#{\nXDIM=%d\nYDIM=%d\nZDIM=%d\nVDIM=1\nTYPE=%s\nPIXSIZE=%d bits\nSCALE=2**0\nCPU=decm\nVX=%f\nVY=%f\nVZ=%f\n#GEOMETRY=CARTESIAN\n' \
                % (vol.shape[0], vol.shape[1], vol.shape[2], btype, bitlen, xPixelSpacing, yPixelSpacing, SliceThickness)
    for _ in range(256-4-len(header)):
        header += '\n'
    header += '##}\n'
    
    with open(fname, 'wb') as file:
        file.write(header.encode('ascii'))
        if vol.dtype == 'bool':
            vol = vol.astype(np.uint8)
        file.write(vol.tobytes('F'))
    
    return
        
def readMEDIT(fname):
    """
    Read a mesh generated by the CGAL mesher, which is saved in MEDIT format
    
    Directly translated from the Matlab version

    Parameters
    ----------
    fname : str
        name of the file to be loaded.

    Returns
    -------
    elements : NumPy array
        list of elements in the mesh. Zero-based
    nodes : NumPy array
        node locations of the mesh, in mm.
    faces : NumPy array
        list of faces in the mesh. In case of 2D, it's the same as elements. Zero-based
    nnpe : int
        size of dimension 1 of elements, i.e. 4 for 3D mesh and 3 for 2D mesh.

    """
    
    if not '.mesh' in fname:
        fname = fname + '.mesh'
    file = open(fname)
    all_lines = file.readlines()
    file.close()
    cur = 0
    while(cur < len(all_lines)):
        line = all_lines[cur]
        if 'Vertices' in line:
            break
        else:
            cur += 1
    
    line = all_lines[cur+1]
    nn = np.fromstring(line, dtype=int, sep='\t')[0]
    nodes = []
    for i in range(nn):
        nodes.append(np.fromstring(all_lines[cur+2+i], sep='\t'))
    nodes = np.array(nodes)[:,:-1]
    # Continue reading
    cur += 2+nn
    while(cur < len(all_lines)):
        line = all_lines[cur]
        if 'Triangles' in line:
            tri = True
            break
        elif 'Tetrahedra' in line:
            tet = True
            break
        else:
            cur += 1
    
    if tri:
        line = all_lines[cur+1]
        nt = np.fromstring(line, dtype=int, sep='\t')[0]
        faces = []
        for i in range(nt):
            faces.append(np.fromstring(all_lines[cur+2+i], dtype=int, sep='\t'))
        faces = np.array(faces)
        cur += 2+nt
        while(cur < len(all_lines)):
            line = all_lines[cur]
            if 'Tetrahedra' in line:
                tet = True
                break
            else:
                cur += 1
                
    # Read the tetrahedrons
    if tet:
        line = all_lines[cur+1]
        ne = np.fromstring(line, dtype=int, sep='\t')[0]
        elements = []
        for i in range(ne):
            elements.append(np.fromstring(all_lines[cur+2+i], dtype=int, sep='\t'))
        elements = np.array(elements)
        nnpe = 4
    else:
        elements = faces
        nnpe = 3
        
    return elements, nodes, faces, nnpe
